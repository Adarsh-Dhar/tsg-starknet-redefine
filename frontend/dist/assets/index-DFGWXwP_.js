import{s as Da,a as Ge,f as Ee,b as _,A as f,e as Ut,u as D,c as Ye,C as I,d as Dt,p as Kt,g as W,h as lr,i as Ka,j as be,k as B,l as Ze,m as dr,n as m,o as K,q as F,r as pr,t as sn,v as P,w as Et,x as Bt,y as cn,z as x,B as hr,S as Mn,D as Mt,E as ae,F as Rt,G as ut,H as lt,I as Z,J as Ma,K as fi,L as Ra,M as gi,N as za,O as Fa,P as Va,Q as qa,R as Ya,T as Za,U as ja,V as Ga,W as Wa,X as Ur,Y as _i,Z as c,_ as mr,$ as q,a0 as qe,a1 as vt,a2 as un,a3 as Xa,a4 as Qa,a5 as Ja,a6 as es,a7 as de,a8 as It,a9 as fr,aa as yn,ab as ts,ac as ns,ad as rs,ae as is,af as oe,ag as gr,ah as os,ai as zt,aj as yi,ak as as,al as bi,am as ki,an as Si,ao as ss,ap as cs,aq as us,ar as se,as as Oe,at as ls,au as vi,av as Oi,aw as xi,ax as ds,ay as ps,az as Ce,aA as on,aB as hs,aC as ms,aD as Pi,aE as fs,aF as gs,aG as _s,aH as ys,aI as Ti,aJ as bs,aK as ks,aL as Ci,aM as Ei,aN as Bi,aO as Ss,aP as vs,aQ as Os,aR as xs,aS as Ps,aT as Ts,aU as Cs,aV as Es,aW as Bs,aX as Is,aY as ws,aZ as $s,a_ as As,a$ as Ns,b0 as Hs,b1 as Ls,b2 as Us,b3 as Ds,b4 as Ks,b5 as Ii,b6 as Rn,b7 as Ms,b8 as Rs,b9 as it,ba as Dr,bb as Kr,bc as zs,bd as Fs,be as wi,bf as ln,bg as $i,bh as Vs,bi as Ai,bj as qs,bk as ot,bl as bn,bm as Mr,bn as U,bo as We,bp as Ys,bq as Zs,br as dn,bs as Ft,bt as kn,bu as zn,bv as js,bw as Gs,bx as Ws,by as Xs,bz as Rr,bA as Qs,bB as zr,bC as Js,bD as ec,bE as tc,bF as nc}from"./index-DTE64tjG.js";import{bG as om,bH as am,bI as sm,bJ as cm,bK as um,bL as lm,bM as dm,bN as pm,bO as hm,bP as mm,bQ as fm,bR as gm,bS as _m,bT as ym}from"./index-DTE64tjG.js";const rc=8,ic=2,oc=e=>Uint8Array.from(Da(e,rc).map(t=>parseInt(t,ic))),ac=(e,t)=>(n,r)=>{const i=new Uint8Array(t).fill(0);i.set(n.length>t?e(n):n,0);const s=new Uint8Array(t).fill(54).map((g,y)=>g^i[y]),l=Ee([s,r]),u=e(l),h=new Uint8Array(t).fill(92).map((g,y)=>g^i[y]);return e(Ee([h,u]))},sc=128,_r=(e,t,n=Ge)=>ac(n.hash,sc)(e,t),dt=e=>D(e,(t,[n])=>Ye(n)?t:_(t,f.failedVerify)),Je=e=>_(e,f.calledReserved),cc=e=>_(e,f.calledReturn),Me=(e,t)=>(e.controlStack.push(t),e),uc=e=>Ut(e)?D(e,(t,[n])=>Me(t,Ye(n))):Me(e,!1),lc=e=>Ut(e)?D(e,(t,[n])=>Me(t,!Ye(n))):Me(e,!1),dc=e=>typeof e.controlStack.pop()!="boolean"?_(e,f.unexpectedEndIf):e,pc=e=>{const t=e.controlStack[e.controlStack.length-1];return typeof t!="boolean"?_(e,f.unexpectedElse):(e.controlStack[e.controlStack.length-1]=!t,e)},yr=e=>(t,{hasEncodingCost:n,maximumVmNumberByteLength:r})=>i=>e(i,(o,a)=>{const s=t(a);return Kt(o,s,{hasEncodingCost:n,maximumVmNumberByteLength:r})},{maximumVmNumberByteLength:r}),pt=yr(W),ee=yr(lr),hc=yr(Ka),Ni=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>pt(([t])=>t+1n,{hasEncodingCost:!0,maximumVmNumberByteLength:e});Ni();const Hi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>pt(([t])=>t-1n,{hasEncodingCost:!0,maximumVmNumberByteLength:e});Hi();const Li=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>pt(([t])=>-t,{hasEncodingCost:!0,maximumVmNumberByteLength:e});Li();const Ui=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>pt(([t])=>t<0?-t:t,{hasEncodingCost:!0,maximumVmNumberByteLength:e});Ui();const Di=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>pt(([t])=>t===0n?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});Di();const Ki=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>pt(([t])=>t===0n?0n:1n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});Ki();const Mi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t+n,{hasEncodingCost:!0,maximumVmNumberByteLength:e});Mi();const Ri=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t-n,{hasEncodingCost:!0,maximumVmNumberByteLength:e});Ri();const zi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t!==0n&&n!==0n?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});zi();const Fi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t!==0n||n!==0n?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});Fi();const br=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t===n?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});br();const Vi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>Dt(br({maximumVmNumberByteLength:e}),dt);Vi();const qi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t===n?0n:1n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});qi();const kr=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t<n?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});kr();const mc=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t<=n?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});kr();const Yi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t>n?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});Yi();const Zi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t>=n?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});Zi();const ji=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t<n?t:n,{hasEncodingCost:!0,maximumVmNumberByteLength:e});ji();const Gi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>ee(([t,n])=>t>n?t:n,{hasEncodingCost:!0,maximumVmNumberByteLength:e});Gi();const Wi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>hc(([t,n,r])=>n<=t&&t<r?1n:0n,{hasEncodingCost:!1,maximumVmNumberByteLength:e});Wi();const Sr=(e,t)=>{const[n,r]=e.stack.slice(-2),i=n?.length??0,o=r?.length??0;return e.metrics.arithmeticCost+=i*o,t(e)},Xi=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>t=>Sr(t,ee(([n,r])=>n*r,{hasEncodingCost:!0,maximumVmNumberByteLength:e}));Xi();const vr=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>t=>Sr(t,()=>lr(t,(n,[r,i])=>i===0n?_(n,f.divisionByZero):Kt(n,r/i,{hasEncodingCost:!0,maximumVmNumberByteLength:e}),{maximumVmNumberByteLength:e}));vr();const fc=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>t=>Sr(t,()=>lr(t,(n,[r,i])=>i===0n?_(n,f.divisionByZero):Kt(n,r%i,{hasEncodingCost:!0,maximumVmNumberByteLength:e}),{maximumVmNumberByteLength:e}));vr();const Qi=e=>be(e,(t,[n,r])=>B(t,[Ze(dr(n,r))])),gc=Dt(Qi,dt),Or=e=>t=>be(t,(n,[r,i])=>r.length===i.length?B(n,[e(r,i)]):_(n,f.mismatchedBitwiseOperandLength,`First item length: ${r.length} bytes. Second item length: ${i.length} bytes.`)),_c=Or((e,t)=>e.map((n,r)=>n&t[r])),yc=Or((e,t)=>e.map((n,r)=>n|t[r])),bc=Or((e,t)=>e.map((n,r)=>n^t[r])),kc=m(e=>_(e,f.unknownOpcode)),Ji=e=>(e&128)!==0,Sc=(e,t,n)=>e>1&&t===0&&!Ji(n),Fr=(e,t,n,r)=>e[t]===2&&n!==0&&!Ji(e[r])&&!Sc(n,e[r],e[r+1]),eo=e=>{const t=e.length>8&&e.length<72,n=e[0]===48,r=e[1]===e.length-2,i=e[3];if(i===void 0)return!1;const o=i<=e.length-7,a=Fr(e,2,i,4),s=4+i,l=s+1,u=e[l];if(u===void 0)return!1;const d=l+1,p=d+u===e.length,h=Fr(e,s,u,d);return t&&n&&r&&o&&a&&p&&h},Fn=(e,t)=>e.length===0||t.includes(e[e.length-1])&&(e.length===I.schnorrSignatureLength+1||eo(e.slice(0,e.length-1))),Vn=e=>({signature:e.slice(0,-1),signingSerializationType:e.slice(-1)}),vc=({ripemd160:e}={ripemd160:ae})=>t=>D(t,(n,[r])=>Mt(n,{messageLength:r.length,resultIsHashed:!1},i=>B(i,[e.hash(r)]))),Oc=({sha1:e}={sha1:Rt})=>t=>D(t,(n,[r])=>Mt(n,{messageLength:r.length,resultIsHashed:!1},i=>B(i,[e.hash(r)]))),xc=({sha256:e}={sha256:K})=>t=>D(t,(n,[r])=>Mt(n,{messageLength:r.length,resultIsHashed:!1},i=>B(i,[e.hash(r)]))),Pc=({ripemd160:e,sha256:t}={ripemd160:ae,sha256:K})=>n=>D(n,(r,[i])=>Mt(r,{messageLength:i.length,resultIsHashed:!0},o=>B(o,[e.hash(t.hash(i))]))),Tc=({sha256:e}={sha256:K})=>t=>D(t,(n,[r])=>Mt(n,{messageLength:r.length,resultIsHashed:!0},i=>B(i,[Bt(r,e)]))),Cc=e=>(e.lastCodeSeparator=e.ip,e),to=({secp256k1:e,sha256:t}={secp256k1:F,sha256:K})=>n=>be(n,(r,[i,o])=>{if(!sn(o))return _(r,f.invalidPublicKeyEncoding);if(!Fn(i,Mn))return _(r,f.invalidSignatureEncoding,`Transaction signature (including signing serialization): ${P(i)}`);if(i.length===0)return B(r,[Ze(!1)]);const a=pr(r.instructions.slice(r.lastCodeSeparator+1)),{signingSerializationType:s,signature:l}=Vn(i),u=Et(r.program,{coveredBytecode:a,signingSerializationType:s},t),d=Bt(u,t);r.metrics.signatureCheckCount+=1;const p=1;r.metrics.hashDigestIterations+=p+cn(u.length),r.signedMessages.push({digest:d,serialization:u});const h=l.length===I.schnorrSignatureLength,g=h?e.verifySignatureSchnorr(l,o,d):e.verifySignatureDERLowS(l,o,d);return g?B(r,[Ze(g)]):_(r,f.nonNullSignatureFailure,`Algorithm used: ${h?"Schnorr":"ECDSA"}.`)}),Ec=e=>e.toString(2).replace(/0/gu,"").length;var pn;(function(e){e.invalidBitfieldSize="BitfieldDecode error: bitfield exceeds maximum length (32 bits).",e.bitsSetBeyondExpectedRange="BitfieldDecode error: the decoded bitfield includes bits set beyond the expected range."})(pn||(pn={}));const Bc=(e,t)=>{const n=Math.floor((t+7)/8);if(e.length!==n)return x(pn.invalidBitfieldSize,`Bitfield length: ${e.length}, expected length: ${n}.`);let r=0n;for(let o=0;o<n;o++)r|=BigInt(e[o])<<BigInt(8*o);const i=(1n<<BigInt(t))-1n;return(r&i)!==r?x(pn.bitsSetBeyondExpectedRange,`Bitfield: ${r}, expected bit length: ${t}.`):r},xr=({secp256k1:e,sha256:t,enforceOperationLimit:n}={enforceOperationLimit:!0,secp256k1:F,sha256:K})=>r=>W(r,(i,o)=>{const a=Number(o);if(a<0)return _(i,f.invalidNaturalNumber,`Indicated public key count: ${a}.`);if(a>20)return _(i,f.exceedsMaximumMultisigPublicKeyCount,`Indicated public key count: ${a}.`);const s=a>0?i.stack.splice(-a):[];return i.operationCount+=a,n&&i.operationCount>I.maximumOperationCount?_(i,f.exceededMaximumOperationCount):W(i,(l,u)=>{const d=Number(u);if(d<0)return _(l,f.invalidNaturalNumber,`Indicated signature count: ${d}.`);if(d>a)return _(l,f.insufficientPublicKeys,`Indicated signature count: ${d}.`);const p=d>0?l.stack.splice(-d):[];return D(l,(h,[g])=>{const y=p.length>0?pr(h.instructions.slice(i.lastCodeSeparator+1)):Uint8Array.of();if(g.length!==0){const S=Bc(g,s.length);if(typeof S=="string")return _(h,f.invalidCheckBitsValue,S);const M=Ec(S);if(M!==p.length)return _(h,f.invalidCheckBitsSignatureCount,`CheckBits signatures configured: ${M}; signatures required: ${p.length}.`);let b=0;for(let w=0;w<p.length;w++,b++){if(S>>BigInt(b)===0n)return _(h,"Expected to be unreachable: unexpected end of bitfield.");for(;(S>>BigInt(b)&1n)===0n;)b++;if(b>=s.length)return _(h,"Expected to be unreachable: more set bits than available public keys.");const R=p[w],V=s[b];if(!sn(V))return _(h,f.invalidPublicKeyEncoding,`Provided public key: ${P(V)}`);if(!Fn(R,Mn))return _(h,f.invalidSignatureEncoding,`Transaction signature (including signing serialization type): ${P(R)}`);const{signingSerializationType:ke,signature:Se}=Vn(R),ve=Et(i.program,{coveredBytecode:y,signingSerializationType:ke},t),Xe=Bt(ve,t);h.metrics.signatureCheckCount+=1;const Re=1;if(h.metrics.hashDigestIterations+=Re+cn(ve.length),h.signedMessages.push({digest:Xe,serialization:ve}),Se.length!==I.schnorrSignatureLength)return _(h,f.nonSchnorrSizedSignatureInSchnorrMultiSig,`Provided signature: ${P(Se)}`);if(!e.verifySignatureSchnorr(Se,V,Xe))return _(h,f.nonNullSignatureFailure,`Algorithm used: 'Schnorr'. CheckBits: ${S.toString(2)}.`)}return S>>BigInt(b)!==0n?_(h,"Expected to be unreachable: unexpected bits set after processing all signatures."):B(h,[Ze(!0)])}let v=0,C=p.length,T=s.length;for(;C>0&&T>0&&v+T>=C&&v!==d;){const S=s[T-1],M=p[C-1];if(!sn(S))return _(h,f.invalidPublicKeyEncoding,`Provided public key: ${P(S)}`);if(!Fn(M,Mn))return _(h,f.invalidSignatureEncoding,`Transaction signature (including signing serialization type): ${P(M)}`);if(M.length===0){C-=1;continue}const{signingSerializationType:b,signature:w}=Vn(M),R=Et(i.program,{coveredBytecode:y,signingSerializationType:b},t),V=Bt(R,t),ke=1;if(h.metrics.hashDigestIterations+=ke+cn(R.length),h.signedMessages.push({digest:V,serialization:R}),w.length===I.schnorrSignatureLength)return _(h,f.schnorrSizedSignatureInEcdsaMultiSig,`Provided signature: ${P(w)}`);e.verifySignatureDERLowS(w,S,V)&&(v+=1,C-=1),T-=1}const k=v===d;return!p.every(S=>S.length===0)&&(h.metrics.signatureCheckCount+=s.length,!k)?_(h,f.nonNullSignatureFailure):B(h,[Ze(k)])})})}),Ic=({secp256k1:e,sha256:t}={secp256k1:F,sha256:K})=>Dt(to({secp256k1:e,sha256:t}),dt),no=({enforceOperationLimit:e,secp256k1:t,sha256:n})=>Dt(xr({enforceOperationLimit:e,secp256k1:t,sha256:n}),dt),wc=e=>e.length===0||e.length===I.schnorrSignatureLength||eo(e),ro=({secp256k1:e,sha256:t})=>n=>hr(n,(r,[i,o,a])=>{if(!wc(i))return _(r,f.invalidSignatureEncoding,`Data signature: ${P(i)}`);if(!sn(a))return _(r,f.invalidPublicKeyEncoding,`Provided public key: ${P(a)}`);if(i.length===0)return B(n,[Ze(!1)]);const s=t.hash(o);r.metrics.signatureCheckCount+=1,r.metrics.hashDigestIterations+=cn(o.length),r.signedMessages.push({digest:s,message:o});const u=i.length===I.schnorrSignatureLength?e.verifySignatureSchnorr(i,a,s):e.verifySignatureDERLowS(i,a,s);return u?B(r,[Ze(u)]):_(r,f.nonNullSignatureFailure)}),$c=({secp256k1:e,sha256:t}={secp256k1:F,sha256:K})=>Dt(ro({secp256k1:e,sha256:t}),dt),Ac=e=>D(e,(t,[n])=>B(t,[n.slice().reverse()])),io=({maximumStackItemLength:e=I.maximumStackItemLength}={})=>t=>be(t,(n,[r,i])=>ut(n,Ee([r,i]),{maximumStackItemLength:e}));io();const Nc=e=>W(e,(t,n)=>{const r=Number(n);return D(t,(i,[o])=>r<0||r>o.length?_(i,f.invalidSplitIndex,`stack item length: ${o.length}; requested split index: ${r}.`):B(i,[o.slice(0,r),o.slice(r)]))}),Hc=(e,t)=>{if(e.length===t)return e;let n=0;e.length>0&&(n=e[e.length-1]&128,e[e.length-1]&=127);const r=Array.from(e);for(;r.length<t-1;)r.push(0);return r.push(n),Uint8Array.from(r)},oo=({maximumStackItemLength:e=I.maximumStackItemLength}={})=>t=>W(t,(n,r)=>{const i=Number(r);return i>e?_(n,f.exceededMaximumStackItemLength,`Maximum stack item length: ${e} bytes. Item length: ${i} bytes.`):W(n,(o,[a])=>{const s=lt(a);return s.length>i?_(o,f.insufficientLength,`Minimum necessary byte length: ${s.length}. Requested byte length: ${i}.`):B(o,[Hc(s,i)])},{maximumVmNumberByteLength:e,requireMinimalEncoding:!1})});oo();const ao=({maximumStackItemLength:e=I.maximumStackItemLength,maximumVmNumberByteLength:t=I.maximumVmNumberByteLength}={})=>n=>W(n,(r,[i])=>{const o=lt(i);return o.length>t?_(r,f.exceededMaximumVmNumberByteLength,`Maximum VM number byte length: ${t}; required byte length: ${o.length}.`):B(r,[o])},{maximumVmNumberByteLength:e,requireMinimalEncoding:!1});ao();const Lc=e=>Z(e,BigInt(e.program.inputIndex)),so=({maximumStackItemLength:e=I.maximumStackItemLength}={})=>t=>ut(t,pr(t.instructions.slice(t.lastCodeSeparator+1)),{maximumStackItemLength:e});so();const Uc=e=>Z(e,BigInt(Ma(e.program.transaction.version))),Dc=e=>Z(e,BigInt(e.program.transaction.inputs.length)),Kc=e=>Z(e,BigInt(e.program.transaction.outputs.length)),Mc=e=>Z(e,BigInt(e.program.transaction.locktime)),Vt=(e,t)=>W(e,(n,[r])=>{const i=n.program.sourceOutputs[Number(r)];return i===void 0?_(n,f.invalidTransactionUtxoIndex,`Transaction UTXO count: ${n.program.sourceOutputs.length}; requested index: ${r}.`):t(e,[i])}),Rc=e=>Vt(e,(t,[n])=>Z(t,n.valueSatoshis)),co=({maximumStackItemLength:e=I.maximumStackItemLength}={})=>t=>Vt(t,(n,[r])=>ut(n,r.lockingBytecode.slice(),{maximumStackItemLength:e}));co();const Sn=(e,t)=>W(e,(n,[r])=>{const i=n.program.transaction.inputs[Number(r)];return i===void 0?_(n,f.invalidTransactionInputIndex,`Transaction input count: ${n.program.transaction.inputs.length}; requested index: ${r}.`):t(e,[i])}),zc=e=>Sn(e,(t,[n])=>B(t,[n.outpointTransactionHash.slice().reverse()])),Fc=e=>Sn(e,(t,[n])=>Z(t,BigInt(n.outpointIndex))),uo=({maximumStackItemLength:e=I.maximumStackItemLength}={})=>t=>Sn(t,(n,[r])=>ut(n,r.unlockingBytecode.slice(),{maximumStackItemLength:e}));uo();const Vc=e=>Sn(e,(t,[n])=>Z(t,BigInt(n.sequenceNumber))),qt=(e,t)=>W(e,(n,[r])=>{const i=n.program.transaction.outputs[Number(r)];return i===void 0?_(n,f.invalidTransactionOutputIndex,`Transaction output count: ${n.program.transaction.outputs.length}; requested index: ${r}.`):t(e,[i])}),qc=e=>qt(e,(t,[n])=>Z(t,n.valueSatoshis)),lo=({maximumStackItemLength:e=I.maximumStackItemLength}={})=>t=>qt(t,(n,[r])=>ut(n,r.lockingBytecode.slice(),{maximumStackItemLength:e}));lo();const xe=e=>e,$e=e=>_(e,f.calledUpgradableNop),yt=e=>_(e,f.unknownOpcode),Yc=e=>D(e,(t,[n])=>(t.alternateStack.push(n),t)),Zc=e=>{const t=e.alternateStack.pop();return t===void 0?_(e,f.emptyAlternateStack):B(e,[t])},jc=e=>be(e,t=>t),Gc=e=>be(e,(t,[n,r])=>B(t,[n,r,n.slice(),r.slice()],{pushedBytes:n.length+r.length})),Wc=e=>hr(e,(t,[n,r,i])=>B(t,[n,r,i,n.slice(),r.slice(),i.slice()],{pushedBytes:n.length+r.length+i.length})),Xc=e=>fi(e,(t,[n,r,i,o])=>B(t,[n,r,i,o,n.slice(),r.slice()],{pushedBytes:n.length+r.length})),Qc=e=>Ra(e,(t,[n,r,i,o,a,s])=>B(t,[i,o,a,s,n,r],{pushedBytes:n.length+r.length})),Jc=e=>fi(e,(t,[n,r,i,o])=>B(t,[i,o,n,r],{pushedBytes:0})),eu=e=>D(e,(t,[n])=>Ye(n)?B(t,[n,n.slice()],{pushedBytes:n.length}):B(t,[n],{pushedBytes:0})),tu=e=>B(e,[lt(BigInt(e.stack.length))]),nu=e=>D(e,t=>t),ru=e=>D(e,(t,[n])=>B(t,[n,n.slice()],{pushedBytes:n.length})),iu=e=>be(e,(t,[,n])=>B(t,[n],{pushedBytes:0})),ou=e=>be(e,(t,[n,r])=>B(t,[n,r,n.slice()],{pushedBytes:n.length})),au=e=>W(e,(t,[n])=>{const r=t.stack[t.stack.length-1-Number(n)];return r===void 0?_(e,f.invalidStackIndex,`Current stack depth: ${t.stack.length}; requested depth: ${n}.`):B(t,[r.slice()])}),su=e=>W(e,(t,[n])=>{const r=Number(n),i=t.stack.length-1-r;if(i<0||i>t.stack.length-1)return _(e,f.invalidStackIndex,`Current stack depth: ${t.stack.length}; requested depth: ${r}.`);const o=t.stack.splice(i,1)[0];return B(t,[o],{pushedBytes:o.length+r})}),cu=e=>hr(e,(t,[n,r,i])=>B(t,[r,i,n],{pushedBytes:0})),uu=e=>be(e,(t,[n,r])=>B(t,[r,n],{pushedBytes:0})),lu=e=>be(e,(t,[n,r])=>B(t,[r.slice(),n,r],{pushedBytes:r.length})),du=e=>D(e,(t,[n])=>{const r=lt(BigInt(n.length));return B(t,[n,r],{pushedBytes:r.length})}),po=(e,t)=>{const n=e.stack[e.stack.length-1];if(n===void 0)return _(e,f.emptyStack);const r=gi(n,{maximumVmNumberByteLength:5,requireMinimalEncoding:!0});if(za(r))return _(e,f.invalidVmNumber,r);const i=Number(r);return i<0?_(e,f.negativeLocktime,`Locktime: ${i}.`):t(e,i)},pu=(e,t)=>e<5e8&&t<5e8||e>=5e8&&t>=5e8,Vr=e=>po(e,(t,n)=>{if(!pu(t.program.transaction.locktime,n))return _(t,f.incompatibleLocktimeType,`Transaction locktime: ${t.program.transaction.locktime}; required locktime: ${n}.`);if(n>t.program.transaction.locktime)return _(t,f.unsatisfiedLocktime,`Transaction locktime: ${t.program.transaction.locktime}; required locktime: ${n}.`);const{sequenceNumber:r}=t.program.transaction.inputs[t.program.inputIndex];return r===4294967295?_(t,f.locktimeDisabled,`Sequence number: ${r}.`):t}),Gt=(e,t)=>(e&t)!==0,qr=e=>po(e,(t,n)=>{const{sequenceNumber:r}=t.program.transaction.inputs[t.program.inputIndex];return Gt(n,2147483648)?t:t.program.transaction.version<2?_(t,f.checkSequenceUnavailable,`Transaction version: ${t.program.transaction.version}.`):Gt(r,2147483648)?_(t,f.unmatchedSequenceDisable,`Sequence number: ${r}.`):Gt(n,4194304)!==Gt(r,4194304)?_(t,f.incompatibleSequenceType,`Sequence number: ${r}; required sequence number: ${n}.`):(n&65535)>(r&65535)?_(t,f.unsatisfiedSequenceNumber,`Sequence number: ${r}; required sequence number: ${n}.`):t}),hn={baseInstructionCost:100,densityControlBaseLength:41,hashDigestIterationCostConsensus:64,hashDigestIterationCostStandard:192,hashDigestIterationsPerByteNonstandard:3.5,hashDigestIterationsPerByteStandard:.5,maximumBytecodeLength:1e4,maximumConsensusVersion:2,maximumControlStackDepth:100,maximumDataCarrierBytes:223,maximumFungibleTokenAmount:"9223372036854775807",maximumOperationCount:201,maximumStackDepth:1e3,maximumStackItemLength:520,maximumStandardLockingBytecodeLength:-1,maximumStandardTransactionSize:1e5,maximumStandardUnlockingBytecodeLength:1650,maximumTokenCommitmentLength:40,maximumTransactionLengthBytes:1e6,maximumTransactionSignatureChecks:3e3,maximumVmNumberByteLength:8,minimumConsensusVersion:1,minimumTransactionLengthBytes:65,operationCostBudgetPerByte:800,schnorrSignatureLength:64,signatureCheckCost:26e3},Yr=e=>Math.floor((e+60)/43),hu=f,mu=e=>e.reduce((t,n)=>n.outpointIndex===0?[...t,P(n.outpointTransactionHash)]:t,[]),fu=e=>e.reduce((t,n)=>{if(n.token===void 0)return t;const r=P(n.token.category);return{availableImmutableTokens:[...t.availableImmutableTokens,...n.token.nft?.capability==="none"?[{categoryHex:P(n.token.category),commitmentHex:P(n.token.nft.commitment)}]:[]],availableMutableTokensByCategory:n.token.nft?.capability==="mutable"?{...t.availableMutableTokensByCategory,[r]:(t.availableMutableTokensByCategory[r]??0)+1}:t.availableMutableTokensByCategory,availableSumsByCategory:{...t.availableSumsByCategory,[r]:(t.availableSumsByCategory[r]??0n)+n.token.amount},inputMintingCategories:[...t.inputMintingCategories,...n.token.nft?.capability==="minting"?[P(n.token.category)]:[]]}},{availableImmutableTokens:[],availableMutableTokensByCategory:{},availableSumsByCategory:{},inputMintingCategories:[]}),gu=e=>e.reduce((t,n)=>{if(n.token===void 0)return t;const r=P(n.token.category);return{outputImmutableTokens:[...t.outputImmutableTokens,...n.token.nft?.capability==="none"?[{categoryHex:P(n.token.category),commitmentHex:P(n.token.nft.commitment)}]:[]],outputMintingCategories:[...t.outputMintingCategories,...n.token.nft?.capability==="minting"?[P(n.token.category)]:[]],outputMutableTokensByCategory:n.token.nft?.capability==="mutable"?{...t.outputMutableTokensByCategory,[r]:(t.outputMutableTokensByCategory[r]??0)+1}:t.outputMutableTokensByCategory,outputSumsByCategory:{...t.outputSumsByCategory,[r]:(t.outputSumsByCategory[r]??0n)+n.token.amount}}},{outputImmutableTokens:[],outputMintingCategories:[],outputMutableTokensByCategory:{},outputSumsByCategory:{}}),_u=(e,t,{maximumTokenCommitmentLength:n})=>{const r=[...t,...e.outputs].find(k=>k.token?.nft?.commitment!==void 0&&k.token.nft.commitment.length>n);if(r!==void 0)return x(f.tokenValidationExcessiveCommitmentLength,`A token commitment exceeds the consensus limit of ${n} bytes. Excessive token commitment length: ${r.token.nft.commitment.length}`);const i=mu(e.inputs),{availableSumsByCategory:o,availableMutableTokensByCategory:a,inputMintingCategories:s,availableImmutableTokens:l}=fu(t),{outputSumsByCategory:u,outputMutableTokensByCategory:d,outputMintingCategories:p,outputImmutableTokens:h}=gu(e.outputs),g=[...i,...s],y=p.find(k=>!g.includes(k));if(y!==void 0)return x(f.tokenValidationInvalidMintingToken,`Invalid output minting token category: ${y}`);for(const[k,O]of Object.entries(u)){if(O>BigInt(hn.maximumFungibleTokenAmount))return x(f.tokenValidationExcessiveAmount,`Category: ${k}, total amount: ${O.toString()}. Consensus maximum amount: ${hn.maximumFungibleTokenAmount}`);const S=o[k];if(S===void 0&&O>0&&!i.includes(k))return x(f.tokenValidationInvalidFungibleMint,`Category: ${k}, tokens created: ${O}`);if(S!==void 0&&O>S)return x(f.tokenValidationOutputsExceedInputs,`Category: ${k}, input amount: ${S}, output amount: ${O}`)}const v=Object.entries(d).reduce((k,[O,S])=>g.includes(O)?k:{...k,[O]:(k[O]??0)-S},a);for(const[k,O]of Object.entries(v))if(O<0)return x(f.tokenValidationExcessiveMutableTokens,`Category: ${k}, excess mutable tokens: ${0-O}`);const{unmatchedImmutableTokens:C}=h.reduce((k,O)=>{const{categoryHex:S,commitmentHex:M}=O;if(g.includes(S))return k;const b=l.findIndex(w=>w.categoryHex===S&&w.commitmentHex===M);return b===-1?{availableImmutableTokens:k.availableImmutableTokens,unmatchedImmutableTokens:[...k.unmatchedImmutableTokens,O]}:(k.availableImmutableTokens.splice(b,1),k)},{availableImmutableTokens:l,unmatchedImmutableTokens:[]}),T=C.reduce((k,O)=>({...k,[O.categoryHex]:(k[O.categoryHex]??0)+1}),{});for(const[k,O]of Object.entries(T)){const S=v[k]??0;if(S<O)return x(f.tokenValidationExcessiveImmutableTokens,`Category ${k}, available mutable tokens: ${S}, new immutable tokens: ${O}`)}return!0},ho=(e,t)=>{const{token:n}=t;if(n===void 0)return Z(e,0n);const r=n.nft?.capability==="minting"?[2]:n.nft?.capability==="mutable"?[1]:[],i=Ee([n.category.slice().reverse(),Uint8Array.from(r)]);return B(e,[i])},mo=(e,t)=>{const{token:n}=t;return n?.nft===void 0?Z(e,0n):ut(e,n.nft.commitment)},fo=(e,t)=>{const{token:n}=t;return n===void 0?Z(e,0n):Z(e,n.amount)},yu=e=>Vt(e,(t,[n])=>ho(t,n)),bu=e=>Vt(e,(t,[n])=>mo(t,n)),ku=e=>Vt(e,(t,[n])=>fo(t,n)),Su=e=>qt(e,(t,[n])=>ho(t,n)),vu=e=>qt(e,(t,[n])=>mo(t,n)),Ou=e=>qt(e,(t,[n])=>fo(t,n)),xu=1e8,Pu=21e6,Wt=Pu*xu,go=(e=!0,{consensus:t=hn,ripemd160:n,secp256k1:r,sha1:i,sha256:o}={ripemd160:ae,secp256k1:F,sha1:Rt,sha256:K})=>{const a=Fa(t);return{continue:s=>s.error===void 0&&s.ip<s.instructions.length,evaluate:(s,{stateEvaluate:l,stateInitialize:u,stateOverride:d})=>{const{unlockingBytecode:p}=s.transaction.inputs[s.inputIndex],{lockingBytecode:h}=s.sourceOutputs[s.inputIndex],g=qe(p),y=qe(h),v={...u(s),...d,instructions:g,program:s,stack:[]};if(p.length>t.maximumBytecodeLength)return _(v,f.exceededMaximumBytecodeLengthUnlocking,`Maximum bytecode length: ${t.maximumBytecodeLength} bytes. Unlocking bytecode length: ${p.length} bytes.`);if(vt(g))return _(v,f.malformedUnlockingBytecode,`Malformed instruction: ${un(c,g[g.length-1])}.`);if(!Ur(p))return _(v,f.requiresPushOnly);if(h.length>t.maximumBytecodeLength)return _(v,f.exceededMaximumBytecodeLengthLocking,`Maximum bytecode length: ${t.maximumBytecodeLength} bytes. Locking bytecode length: ${h.length} bytes.`);if(vt(y))return _(v,f.malformedLockingBytecode,`Malformed instruction: ${un(c,y[y.length-1])}.`);const C=l(v);if(C.error!==void 0)return C;if(C.controlStack.length!==0)return _(C,f.nonEmptyControlStackUnlockingBytecode,`Remaining control stack depth: ${C.controlStack.length}.`);const T=l({...u(s),...d,instructions:y,metrics:C.metrics,program:s,stack:C.stack});if(T.error!==void 0)return T;if(T.controlStack.length!==0)return _(T,f.nonEmptyControlStackLockingBytecode,`Remaining control stack depth: ${T.controlStack.length}.`);const k=Xa(h),O=Qa(h);if(!k&&!O)return T.stack.length!==1?_(T,f.requiresCleanStackLockingBytecode,`Remaining stack depth: ${T.stack.length}.`):T;const S=T.stack[T.stack.length-1];if(!Ye(S))return _(T,f.unmatchedP2shRedeemBytecode,`Top stack item: "${P(S)}".`);const M=structuredClone(C.stack),b=M.pop()??Uint8Array.of();if(k&&M.length===0&&Ja(b))return T;const w=qe(b),R=vt(w)?{...T,error:f.malformedP2shBytecode}:l({...u(s),...d,instructions:w,metrics:T.metrics,program:s,stack:M});return R.controlStack.length!==0?_(R,f.nonEmptyControlStackRedeemBytecode,`Remaining control stack depth: ${R.controlStack.length}.`):R.stack.length!==1?_(R,f.requiresCleanStackRedeemBytecode,`Remaining stack depth: ${R.stack.length}.`):R},every:s=>{const{unlockingBytecode:l}=s.program.transaction.inputs[s.program.inputIndex];return s.metrics.maximumSignatureCheckCount=Yr(l.length),e&&s.metrics.signatureCheckCount>s.metrics.maximumSignatureCheckCount?_(s,f.exceededMaximumSignatureCheckCount,`Maximum signature check count: ${s.metrics.maximumSignatureCheckCount}; signature check count following operation: ${s.metrics.signatureCheckCount}.`):s.stack.length+s.alternateStack.length>t.maximumStackDepth?_(s,f.exceededMaximumStackDepth,`Maximum stack depth: ${t.maximumStackDepth}.`):s.operationCount>t.maximumOperationCount?_(s,f.exceededMaximumOperationCount):s},initialize:s=>{const{unlockingBytecode:l}=s.transaction.inputs[s.inputIndex],u=t.densityControlBaseLength+l.length,d=e?t.hashDigestIterationsPerByteStandard:t.hashDigestIterationsPerByteNonstandard;return{alternateStack:[],controlStack:[],functionCount:0,functionTable:{},ip:0,lastCodeSeparator:-1,metrics:{arithmeticCost:0,definedFunctions:0,densityControlLength:u,evaluatedInstructionCount:0,hashDigestIterations:0,maximumHashDigestIterations:Math.floor(d*u),maximumOperationCost:Math.floor(u*t.operationCostBudgetPerByte),maximumSignatureCheckCount:Yr(l.length),operationCost:0,signatureCheckCount:0,stackPushedBytes:0},operationCount:0,signedMessages:[]}},operations:{[c.OP_0]:a,[c.OP_PUSHBYTES_1]:a,[c.OP_PUSHBYTES_2]:a,[c.OP_PUSHBYTES_3]:a,[c.OP_PUSHBYTES_4]:a,[c.OP_PUSHBYTES_5]:a,[c.OP_PUSHBYTES_6]:a,[c.OP_PUSHBYTES_7]:a,[c.OP_PUSHBYTES_8]:a,[c.OP_PUSHBYTES_9]:a,[c.OP_PUSHBYTES_10]:a,[c.OP_PUSHBYTES_11]:a,[c.OP_PUSHBYTES_12]:a,[c.OP_PUSHBYTES_13]:a,[c.OP_PUSHBYTES_14]:a,[c.OP_PUSHBYTES_15]:a,[c.OP_PUSHBYTES_16]:a,[c.OP_PUSHBYTES_17]:a,[c.OP_PUSHBYTES_18]:a,[c.OP_PUSHBYTES_19]:a,[c.OP_PUSHBYTES_20]:a,[c.OP_PUSHBYTES_21]:a,[c.OP_PUSHBYTES_22]:a,[c.OP_PUSHBYTES_23]:a,[c.OP_PUSHBYTES_24]:a,[c.OP_PUSHBYTES_25]:a,[c.OP_PUSHBYTES_26]:a,[c.OP_PUSHBYTES_27]:a,[c.OP_PUSHBYTES_28]:a,[c.OP_PUSHBYTES_29]:a,[c.OP_PUSHBYTES_30]:a,[c.OP_PUSHBYTES_31]:a,[c.OP_PUSHBYTES_32]:a,[c.OP_PUSHBYTES_33]:a,[c.OP_PUSHBYTES_34]:a,[c.OP_PUSHBYTES_35]:a,[c.OP_PUSHBYTES_36]:a,[c.OP_PUSHBYTES_37]:a,[c.OP_PUSHBYTES_38]:a,[c.OP_PUSHBYTES_39]:a,[c.OP_PUSHBYTES_40]:a,[c.OP_PUSHBYTES_41]:a,[c.OP_PUSHBYTES_42]:a,[c.OP_PUSHBYTES_43]:a,[c.OP_PUSHBYTES_44]:a,[c.OP_PUSHBYTES_45]:a,[c.OP_PUSHBYTES_46]:a,[c.OP_PUSHBYTES_47]:a,[c.OP_PUSHBYTES_48]:a,[c.OP_PUSHBYTES_49]:a,[c.OP_PUSHBYTES_50]:a,[c.OP_PUSHBYTES_51]:a,[c.OP_PUSHBYTES_52]:a,[c.OP_PUSHBYTES_53]:a,[c.OP_PUSHBYTES_54]:a,[c.OP_PUSHBYTES_55]:a,[c.OP_PUSHBYTES_56]:a,[c.OP_PUSHBYTES_57]:a,[c.OP_PUSHBYTES_58]:a,[c.OP_PUSHBYTES_59]:a,[c.OP_PUSHBYTES_60]:a,[c.OP_PUSHBYTES_61]:a,[c.OP_PUSHBYTES_62]:a,[c.OP_PUSHBYTES_63]:a,[c.OP_PUSHBYTES_64]:a,[c.OP_PUSHBYTES_65]:a,[c.OP_PUSHBYTES_66]:a,[c.OP_PUSHBYTES_67]:a,[c.OP_PUSHBYTES_68]:a,[c.OP_PUSHBYTES_69]:a,[c.OP_PUSHBYTES_70]:a,[c.OP_PUSHBYTES_71]:a,[c.OP_PUSHBYTES_72]:a,[c.OP_PUSHBYTES_73]:a,[c.OP_PUSHBYTES_74]:a,[c.OP_PUSHBYTES_75]:a,[c.OP_PUSHDATA_1]:a,[c.OP_PUSHDATA_2]:a,[c.OP_PUSHDATA_4]:a,[c.OP_1NEGATE]:m(q(-1)),[c.OP_RESERVED]:m(Je),[c.OP_1]:m(q(1)),[c.OP_2]:m(q(2)),[c.OP_3]:m(q(3)),[c.OP_4]:m(q(4)),[c.OP_5]:m(q(5)),[c.OP_6]:m(q(6)),[c.OP_7]:m(q(7)),[c.OP_8]:m(q(8)),[c.OP_9]:m(q(9)),[c.OP_10]:m(q(10)),[c.OP_11]:m(q(11)),[c.OP_12]:m(q(12)),[c.OP_13]:m(q(13)),[c.OP_14]:m(q(14)),[c.OP_15]:m(q(15)),[c.OP_16]:m(q(16)),..._i([mr],{[c.OP_NOP]:m(xe),[c.OP_VER]:m(Je),[c.OP_IF]:uc,[c.OP_NOTIF]:lc,[c.OP_VERIF]:Je,[c.OP_VERNOTIF]:Je,[c.OP_ELSE]:pc,[c.OP_ENDIF]:dc,[c.OP_VERIFY]:m(dt),[c.OP_RETURN]:m(cc),[c.OP_TOALTSTACK]:m(Yc),[c.OP_FROMALTSTACK]:m(Zc),[c.OP_2DROP]:m(jc),[c.OP_2DUP]:m(Gc),[c.OP_3DUP]:m(Wc),[c.OP_2OVER]:m(Xc),[c.OP_2ROT]:m(Qc),[c.OP_2SWAP]:m(Jc),[c.OP_IFDUP]:m(eu),[c.OP_DEPTH]:m(tu),[c.OP_DROP]:m(nu),[c.OP_DUP]:m(ru),[c.OP_NIP]:m(iu),[c.OP_OVER]:m(ou),[c.OP_PICK]:m(au),[c.OP_ROLL]:m(su),[c.OP_ROT]:m(cu),[c.OP_SWAP]:m(uu),[c.OP_TUCK]:m(lu),[c.OP_CAT]:m(io(t)),[c.OP_SPLIT]:m(Nc),[c.OP_NUM2BIN]:m(oo(t)),[c.OP_BIN2NUM]:m(ao(t)),[c.OP_SIZE]:m(du),[c.OP_INVERT]:yt,[c.OP_AND]:m(_c),[c.OP_OR]:m(yc),[c.OP_XOR]:m(bc),[c.OP_EQUAL]:m(Qi),[c.OP_EQUALVERIFY]:m(gc),[c.OP_RESERVED1]:m(Je),[c.OP_RESERVED2]:m(Je),[c.OP_1ADD]:m(Ni(t)),[c.OP_1SUB]:m(Hi(t)),[c.OP_2MUL]:yt,[c.OP_2DIV]:yt,[c.OP_NEGATE]:m(Li(t)),[c.OP_ABS]:m(Ui(t)),[c.OP_NOT]:m(Di(t)),[c.OP_0NOTEQUAL]:m(Ki(t)),[c.OP_ADD]:m(Mi(t)),[c.OP_SUB]:m(Ri(t)),[c.OP_MUL]:m(Xi(t)),[c.OP_DIV]:m(vr(t)),[c.OP_MOD]:m(fc(t)),[c.OP_LSHIFT]:yt,[c.OP_RSHIFT]:yt,[c.OP_BOOLAND]:m(zi(t)),[c.OP_BOOLOR]:m(Fi(t)),[c.OP_NUMEQUAL]:m(br(t)),[c.OP_NUMEQUALVERIFY]:m(Vi(t)),[c.OP_NUMNOTEQUAL]:m(qi(t)),[c.OP_LESSTHAN]:m(kr(t)),[c.OP_GREATERTHAN]:m(Yi(t)),[c.OP_LESSTHANOREQUAL]:m(mc(t)),[c.OP_GREATERTHANOREQUAL]:m(Zi(t)),[c.OP_MIN]:m(ji(t)),[c.OP_MAX]:m(Gi(t)),[c.OP_WITHIN]:m(Wi(t)),[c.OP_RIPEMD160]:m(vc({ripemd160:n})),[c.OP_SHA1]:m(Oc({sha1:i})),[c.OP_SHA256]:m(xc({sha256:o})),[c.OP_HASH160]:m(Pc({ripemd160:n,sha256:o})),[c.OP_HASH256]:m(Tc({sha256:o})),[c.OP_CODESEPARATOR]:m(Cc),[c.OP_CHECKSIG]:m(to({secp256k1:r,sha256:o})),[c.OP_CHECKSIGVERIFY]:m(Ic({secp256k1:r,sha256:o})),[c.OP_CHECKMULTISIG]:m(xr({enforceOperationLimit:!0,secp256k1:r,sha256:o})),[c.OP_CHECKMULTISIGVERIFY]:m(no({enforceOperationLimit:!0,secp256k1:r,sha256:o})),...e?{[c.OP_NOP1]:m($e),[c.OP_CHECKLOCKTIMEVERIFY]:m(Vr),[c.OP_CHECKSEQUENCEVERIFY]:m(qr),[c.OP_NOP4]:m($e),[c.OP_NOP5]:m($e),[c.OP_NOP6]:m($e),[c.OP_NOP7]:m($e),[c.OP_NOP8]:m($e),[c.OP_NOP9]:m($e),[c.OP_NOP10]:m($e)}:{[c.OP_NOP1]:m(xe),[c.OP_CHECKLOCKTIMEVERIFY]:m(Vr),[c.OP_CHECKSEQUENCEVERIFY]:m(qr),[c.OP_NOP4]:m(xe),[c.OP_NOP5]:m(xe),[c.OP_NOP6]:m(xe),[c.OP_NOP7]:m(xe),[c.OP_NOP8]:m(xe),[c.OP_NOP9]:m(xe),[c.OP_NOP10]:m(xe)},[c.OP_CHECKDATASIG]:m(ro({secp256k1:r,sha256:o})),[c.OP_CHECKDATASIGVERIFY]:m($c({secp256k1:r,sha256:o})),[c.OP_REVERSEBYTES]:m(Ac),[c.OP_INPUTINDEX]:m(Lc),[c.OP_ACTIVEBYTECODE]:m(so(t)),[c.OP_TXVERSION]:m(Uc),[c.OP_TXINPUTCOUNT]:m(Dc),[c.OP_TXOUTPUTCOUNT]:m(Kc),[c.OP_TXLOCKTIME]:m(Mc),[c.OP_UTXOVALUE]:m(Rc),[c.OP_UTXOBYTECODE]:m(co(t)),[c.OP_OUTPOINTTXHASH]:m(zc),[c.OP_OUTPOINTINDEX]:m(Fc),[c.OP_INPUTBYTECODE]:m(uo(t)),[c.OP_INPUTSEQUENCENUMBER]:m(Vc),[c.OP_OUTPUTVALUE]:m(qc),[c.OP_OUTPUTBYTECODE]:m(lo(t)),[c.OP_UTXOTOKENCATEGORY]:m(yu),[c.OP_UTXOTOKENCOMMITMENT]:m(bu),[c.OP_UTXOTOKENAMOUNT]:m(ku),[c.OP_OUTPUTTOKENCATEGORY]:m(Su),[c.OP_OUTPUTTOKENCOMMITMENT]:m(vu),[c.OP_OUTPUTTOKENAMOUNT]:m(Ou)})},success:s=>{if(s.error!==void 0)return s.error;const l=s.stack[s.stack.length-1];return l===void 0||!Ye(l)?x(f.unsuccessfulEvaluation,l===void 0?"Stack is empty.":`Top stack item: "${P(l)}".`):!0},undefined:kc,verify:({sourceOutputs:s,transaction:l},{evaluate:u,success:d})=>{if(l.inputs.length===0)return x(f.verifyFailedNoInputs);if(l.outputs.length===0)return x(f.verifyFailedNoOutputs);if(l.inputs.length!==s.length)return x(f.verifyFailedMismatchedSourceOutputs,`Transaction input count: ${l.inputs.length}; source outputs count: ${s.length}.`);const p=Va(l).length;if(p<t.minimumTransactionLengthBytes)return x(f.verifyFailedInsufficientLength,`The transaction is ${p} bytes, but transactions must be no smaller than ${t.minimumTransactionLengthBytes} bytes to prevent an exploit of the transaction Merkle tree design.`);if(p>t.maximumTransactionLengthBytes)return x(f.verifyFailedExcessiveLength,`Transaction exceeds maximum byte length: the transaction is ${p} bytes, but the maximum transaction size is ${t.maximumTransactionLengthBytes} bytes.`);const h=s.reduce((k,O)=>k+O.valueSatoshis,0n),g=l.outputs.reduce((k,O)=>k+O.valueSatoshis,0n);if(h>Wt)return x(f.verifyFailedInputsExceedMaxMoney,`Maximum supply in satoshis: ${Wt}, cumulative input value: ${h}.`);if(g>Wt)return x(f.verifyFailedOutputsExceedMaxMoney,`Maximum supply in satoshis: ${Wt}, cumulative output value: ${g}.`);if(g>h)return x(f.verifyFailedOutputsExceedInputs,`Cumulative input value: ${h}, cumulative output value: ${g}.`);const y=l.inputs.map(k=>`outpointTransactionHash: ${P(k.outpointTransactionHash)}, outpointIndex: ${k.outpointIndex}`),v=y.find((k,O)=>y.lastIndexOf(k)!==O);if(v!==void 0)return x(f.verifyFailedDuplicateSourceOutputs,v);if(l.version<t.minimumConsensusVersion||l.version>t.maximumConsensusVersion)return x(f.verifyFailedInvalidVersion,`Encoded version number: ${l.version}.`);if(e){if(p>t.maximumStandardTransactionSize)return x(f.verifyStandardFailedExcessiveLength,`This transaction is ${p} bytes, but the maximum standard transaction size is ${t.maximumStandardTransactionSize} bytes.`);for(const[O,S]of s.entries())if(t.maximumStandardLockingBytecodeLength===-1){if(!qa(S.lockingBytecode))return x(f.verifyStandardFailedNonstandardSourceOutput,`Source output ${O} is non-standard: locking bytecode does not match a standard pattern: P2PKH, P2PK, P2SH, P2MS, or arbitrary data (OP_RETURN).`)}else if(S.lockingBytecode.length>t.maximumStandardLockingBytecodeLength&&Ya(S.lockingBytecode)===!1)return x(f.verifyStandardFailedNonstandardSourceOutput,`Source output ${O} is non-standard: locking bytecode length of ${S.lockingBytecode.length} exceeds the maximum standard locking bytecode length of ${t.maximumStandardLockingBytecodeLength}.`);let k=0;for(const[O,S]of l.outputs.entries()){const M=Za(S.lockingBytecode);M&&(k+=S.lockingBytecode.length+1);const b=t.maximumStandardLockingBytecodeLength!==-1;if(!b&&!ja(S.lockingBytecode))return x(f.verifyStandardFailedNonstandardOutput,`Transaction output ${O} is non-standard: locking bytecode does not match a standard pattern: P2PKH, P2PK, P2SH, P2MS, or arbitrary data (OP_RETURN).`);if(b&&S.lockingBytecode.length>t.maximumStandardLockingBytecodeLength&&!M)return x(f.verifyStandardFailedNonstandardOutput,`Transaction output ${O} is non-standard: locking bytecode length of ${S.lockingBytecode.length} exceeds the maximum standard locking bytecode length of ${t.maximumStandardLockingBytecodeLength} and does not match the standard arbitrary data pattern (OP_RETURN).`);if(Ga(S))return x(f.verifyStandardFailedDustOutput,`Transaction output ${O} must have a value of at least ${Wa(S)} satoshis. Current value: ${S.valueSatoshis}`)}if(k>t.maximumDataCarrierBytes)return x(f.verifyStandardFailedExcessiveDataCarrierBytes,`Standard transactions may carry no more than ${t.maximumDataCarrierBytes} bytes in arbitrary data outputs; this transaction includes ${k} bytes of arbitrary data.`);for(const[O,S]of l.inputs.entries()){if(S.unlockingBytecode.length>t.maximumStandardUnlockingBytecodeLength)return x(f.verifyStandardFailedExcessiveUnlockingBytecodeLength,`The maximum standard unlocking bytecode length is ${t.maximumStandardUnlockingBytecodeLength} bytes, but the unlocking bytecode at input index ${O} is ${S.unlockingBytecode.length} bytes.`);if(!Ur(S.unlockingBytecode))return x(f.verifyStandardFailedNonPushUnlockingBytecode,`The unlocking bytecode at input index ${O} contains non-push operations.`)}}const C=_u(l,s,{maximumTokenCommitmentLength:t.maximumTokenCommitmentLength});if(C!==!0)return C;let T=0;for(const k of l.inputs.keys()){const O=u({inputIndex:k,sourceOutputs:s,transaction:l});if(T+=O.metrics.signatureCheckCount,T>t.maximumTransactionSignatureChecks)return x(f.verifyFailedExcessiveSigChecks,`Transaction exceeded the per-transaction maximum of ${t.maximumTransactionSignatureChecks} signature checks while evaluating input index ${k} of ${l.inputs.length}.`);const S=d(O);if(typeof S=="string")return`Unable to verify transaction: error in evaluating input index ${k}: ${S}`}return!0}}},_o=(e,t=["instructions","program"],n=["alternateStack","controlStack","signedMessages","stack"])=>Object.fromEntries(Object.entries(e).map(([r,i])=>t.includes(r)?[r,i]:n.includes(r)?[r,i.slice()]:[r,structuredClone(i)])),Tu=e=>{const t=_o(e);return delete t.instructions,delete t.program,t.instruction=e.instructions[e.ip],t},vn=e=>{const n=es(256).map(b=>e.operations[b]??e.undefined),r=b=>b.instructions[b.ip],i=b=>(b.ip+=1,b),o=b=>(b.metrics.evaluatedInstructionCount+=1,b),a=b=>n[r(b).opcode],s=b=>b,l=e.every??s,u=b=>{const w=a(b);return i(l(o(w(b))))},d=e.continue,p=(b,w)=>{for(;d(b);)b=w(b);return b},h=e.initialize??(b=>({metrics:{evaluatedInstructionCount:0}})),g=_o,{success:y}=e,v=b=>p(g(b),u),C=b=>{const w=a(b);return i(l(o(w(g(b)))))},T=b=>{const w=[];return w.push(b),p(b,R=>{const V=C(R);return w.push(V),V}),w},k=b=>u(g(b)),O=(b,{stateOverride:w}={})=>e.evaluate(b,{stateEvaluate:v,stateInitialize:h,stateOverride:w});return{debug:(b,{stateOverride:w,maskProgramState:R=!1}={})=>{const V=[],ke=Xe=>{const Re=T(Xe);return V.push(...Re),Re[Re.length-1]??Xe},Se=e.evaluate(b,{stateEvaluate:ke,stateInitialize:h,stateOverride:w}),ve=[...V,Se];return R?ve.map(Tu):ve},evaluate:O,stateClone:g,stateContinue:d,stateDebug:T,stateEvaluate:v,stateInitialize:h,stateStep:k,stateStepMutate:u,stateSuccess:y,verify:b=>e.verify(b,{evaluate:O,initialize:h,success:y})}},Cu=(e=!0)=>vn(go(e));var qn;(function(e){e.excessiveHashing="Program attempted a hashing operation that would exceed the hashing density limit.",e.excessiveOperationCost="Program attempted an operation that would exceed the operation cost density limit."})(qn||(qn={}));const tt={...hu,...qn};var Yn;(function(e){e.unexpectedUntil="Encountered an OP_UNTIL that is not preceded by a matching OP_BEGIN.",e.unexpectedUntilMissingEndIf="Encountered an OP_UNTIL before the previous OP_IF was closed by an OP_ENDIF.",e.excessiveLooping="Program attempted an OP_UNTIL operation that would exceed the limit of repeated bytes.",e.exceededMaximumMemorySlots="Program attempted to use an excessive number of memory slots: stack items, alternate stack items, and/or defined functions.",e.functionIdentifierExcessiveLength="Program attempted to OP_DEFINE a function identifier of excessive length.",e.functionIdentifierPreviouslyDefined="Program attempted to OP_DEFINE a previously-defined function identifier.",e.functionIdentifierUndefined="Program attempted to OP_INVOKE an undefined function identifier.",e.malformedFunction="Program attempted to OP_INVOKE malformed bytecode.",e.invalidShiftBitCount="Program attempted a bitwise shift with an invalid bit count."})(Yn||(Yn={}));const _e={...tt,...Yn};var Zn;(function(e){e.excessiveOperationCostOpPow="Program attempted an OP_POW operation that would have exceed the operation cost density limit.",e.malformedEval="Program attempted to OP_EVAL malformed bytecode."})(Zn||(Zn={}));const jn={..._e,...Zn},yo={maximumStackItemLength:1e4,maximumVmNumberByteLength:1e4};BigInt(yo.maximumVmNumberByteLength);const Ot={...hn,...yo},Eu=(e,{baseInstructionCost:t=Ot.baseInstructionCost,hashDigestIterationCost:n=Ot.hashDigestIterationCostStandard,signatureCheckCost:r=Ot.signatureCheckCost}={})=>e.evaluatedInstructionCount*t+e.signatureCheckCount*r+e.hashDigestIterations*n+e.arithmeticCost+e.stackPushedBytes,bo=(e=!0,{consensus:t=Ot,ripemd160:n,secp256k1:r,sha1:i,sha256:o}={ripemd160:ae,secp256k1:F,sha1:Rt,sha256:K})=>{const a=go(e,{consensus:t,ripemd160:n,secp256k1:r,sha1:i,sha256:o});return{...a,every:s=>(s.metrics.operationCost=Eu(s.metrics,{baseInstructionCost:t.baseInstructionCost,hashDigestIterationCost:e?t.hashDigestIterationCostStandard:t.hashDigestIterationCostConsensus,signatureCheckCost:t.signatureCheckCost}),s.metrics.operationCost>s.metrics.maximumOperationCost?_(s,tt.excessiveOperationCost,`Maximum operation cost: ${s.metrics.maximumOperationCost} (density control length: ${s.metrics.densityControlLength}); operation cost following operation: ${s.metrics.operationCost}.`):s.metrics.hashDigestIterations>s.metrics.maximumHashDigestIterations?_(s,tt.excessiveHashing,`Maximum hash digest iterations: ${s.metrics.maximumHashDigestIterations} (density control length: ${s.metrics.densityControlLength}); hash digest iterations following operation: ${s.metrics.hashDigestIterations}.`):s.stack.length+s.alternateStack.length>t.maximumStackDepth?_(s,tt.exceededMaximumStackDepth,`Maximum stack depth: ${t.maximumStackDepth} items.`):s.controlStack.length>t.maximumControlStackDepth?_(s,tt.exceededMaximumControlStackDepth,`Maximum control stack depth: ${t.maximumControlStackDepth}.`):e&&s.metrics.signatureCheckCount>s.metrics.maximumSignatureCheckCount?_(s,tt.exceededMaximumSignatureCheckCount,`Maximum signature check count: ${s.metrics.maximumSignatureCheckCount}; signature check count following operation: ${s.metrics.signatureCheckCount}.`):s),operations:{...a.operations,..._i([mr,m],{[c.OP_CHECKMULTISIG]:xr({enforceOperationLimit:!1,secp256k1:r,sha256:o}),[c.OP_CHECKMULTISIGVERIFY]:no({enforceOperationLimit:!1,secp256k1:r,sha256:o})})}}},Bu=e=>Ut(e)?Me(e,e.ip):Me(e,-1),Iu=e=>{const t=e.controlStack[e.controlStack.length-1];return typeof t!="number"?_(e,_e.unexpectedUntil):Ut(e)?D(e,(n,[r])=>Ye(r)?(e.controlStack.pop(),n):(n.ip=t,n)):(e.controlStack.pop(),t===-1?e:_(e,_e.unexpectedUntilMissingEndIf))},wu={baseInstructionCost:100,maximumFunctionIdentifierLength:7,maximumMemorySlots:1e3,maximumStandardLockingBytecodeLength:201,maximumStandardUnlockingBytecodeLength:1e4,maximumTokenCommitmentLength:128},Yt={...Ot,...wu},$u=e=>D(e,(t,[n])=>B(t,[n.map(r=>r^255)])),On=(e,t)=>W(e,(n,[r])=>r<0n?_(n,_e.invalidShiftBitCount,`Bit count must be greater than or equal to 0. Provided bit count: ${r}.`):t(n,[r])),Au=({maximumStackItemLength:e=Yt.maximumStackItemLength}={})=>t=>{const n=e*8;return On(t,(r,[i])=>W(r,(o,[a])=>a===0n?Z(o,0n):i>n?_(r,_e.invalidShiftBitCount,`Abandoned excessive OP_LSHIFTNUM. Provided bit count: ${i}.`):Kt(o,a<<i,{hasEncodingCost:!1,maximumVmNumberByteLength:e})))},Nu=({maximumStackItemLength:e=Yt.maximumStackItemLength}={})=>t=>On(t,(n,[r])=>{const o=(n.stack[n.stack.length-1]?.length??0)*8,a=r>o;return W(n,(s,[l])=>{if(l===0n)return Z(s,0n);if(a){const u=l<0;return Z(s,u?-1n:0n)}return Kt(s,l>>r,{hasEncodingCost:!1,maximumVmNumberByteLength:e})})}),Hu=(e,t,n,r)=>{if(!(n>=e.length)){if(r){t.set(e.subarray(n),0);return}t.set(e.subarray(0,e.length-n),n)}},Lu=(e,t)=>{let n=0;for(let r=e.length-1;r>=0;r--){const i=e[r];e[r]=(i<<t|n)&255,n=i>>8-t}return e},Uu=(e,t)=>{let n=0;for(let r=0;r<e.length;r++){const i=e[r];e[r]=(i>>t|n)&255,n=i<<8-t&255}return e},ko=(e,t,n)=>{const r=Number(t);if(!r||!e.length)return e.slice();const i=e.length,o=new Uint8Array(i),a=Math.floor(r/8),s=r%8;return Hu(e,o,a,n),s?n?Lu(o,s):Uu(o,s):o},Du=(e,t)=>ko(e,t,!0),Ku=(e,t)=>ko(e,t,!1),Mu=e=>On(e,(t,[n])=>D(t,(r,[i])=>B(r,[Du(i,n)]))),Ru=e=>On(e,(t,[n])=>D(t,(r,[i])=>B(r,[Ku(i,n)]))),zu=({maximumFunctionIdentifierLength:e=Yt.maximumFunctionIdentifierLength}={})=>t=>D(t,(n,[r])=>{const i=P(r);return r.length>e?_(n,_e.functionIdentifierExcessiveLength,`Function identifier has excessive length. Maximum length: ${e}. Provided length: ${r.length}. Provided identifier: 0x${i}.`):n.functionTable[i]!==void 0?_(n,_e.functionIdentifierPreviouslyDefined,`Function identifier: 0x${i}. Existing contents: ${P(n.functionTable[i])}.`):D(n,(o,[a])=>(o.functionTable[i]=a,o.functionCount+=1,o))}),Fu=e=>D(e,(t,[n])=>{const r=P(n),i=t.functionTable[r];if(i===void 0)return _(t,_e.functionIdentifierUndefined,`Function identifier: 0x${r}.`);const o=qe(i);if(vt(o))return _(t,_e.malformedFunction,`Malformed instruction: ${un(de,o[o.length-1])}.`);const a=1,s=Me(t,{instructions:t.instructions,ip:t.ip+a});return s.ip=0-a,s.instructions=o,s}),So=(e=!0,{consensus:t=Yt,ripemd160:n,secp256k1:r,sha1:i,sha256:o}={ripemd160:ae,secp256k1:F,sha1:Rt,sha256:K})=>{const a=bo(e,{consensus:t,ripemd160:n,secp256k1:r,sha1:i,sha256:o});return{...a,continue:s=>{if(s.error!==void 0)return!1;for(;s.ip>=s.instructions.length&&s.controlStack.length>0&&typeof s.controlStack[s.controlStack.length-1]=="object";){const{instructions:l,ip:u}=s.controlStack.pop();s.ip=u,s.instructions=l}return s.ip<s.instructions.length},every:s=>{const l=a.every(s);return l.stack.length+l.alternateStack.length+l.functionCount>t.maximumMemorySlots?_(l,_e.exceededMaximumMemorySlots,`Maximum memory slots: ${t.maximumMemorySlots}.`):l},operations:{...a.operations,[de.OP_BEGIN]:Bu,[de.OP_UNTIL]:Iu,[de.OP_INVERT]:m($u),[de.OP_DEFINE]:m(zu(t)),[de.OP_INVOKE]:m(Fu),[de.OP_LSHIFTNUM]:m(Au(t)),[de.OP_RSHIFTNUM]:m(Nu(t)),[de.OP_LSHIFTBIN]:m(Mu),[de.OP_RSHIFTBIN]:m(Ru)}}},Vu={densityControlBaseLength:1e4,maximumBytecodeLength:1e5,maximumStackItemLength:1e5,maximumStandardUnlockingBytecodeLength:1e5,maximumVmNumberByteLength:1e5},qu={...Yt,...Vu},Yu=e=>Ut(e)?D(e,(t,[n])=>{const r=qe(n);if(vt(r))return _(t,jn.malformedEval,`Malformed instruction: ${un(It,r[r.length-1])}.`);const i=1,o=Me(t,{instructions:t.instructions,ip:t.ip+i});return o.ip=0-i,o.instructions=r,o}):e,vo=({maximumVmNumberByteLength:e=I.maximumVmNumberByteLength}={})=>t=>{const[n,r]=t.stack.slice(-2),i=n?.length??0,o=r??new Uint8Array(0),a=gi(o,{maximumVmNumberByteLength:8});return typeof a!="bigint"?_(t,jn.invalidVmNumber,`Attempted an OP_POW operation with an invalid exponent. ${a}`):(t.metrics.arithmeticCost+=i*i*8*Number(a),t.metrics.operationCost+t.metrics.arithmeticCost>t.metrics.maximumOperationCost?_(t,jn.excessiveOperationCostOpPow,`Maximum operation cost: ${t.metrics.maximumOperationCost} (density control length: ${t.metrics.densityControlLength}); minimum operation cost following operation: ${t.metrics.operationCost} (excludes costs following rejected OP_POW).`):ee(([s,l])=>s**l,{hasEncodingCost:!0,maximumVmNumberByteLength:e})(t))};vo();const Zu=(e=!0,{consensus:t=qu,ripemd160:n,secp256k1:r,sha1:i,sha256:o}={ripemd160:ae,secp256k1:F,sha1:Rt,sha256:K})=>{const a=So(e,{consensus:t,ripemd160:n,secp256k1:r,sha1:i,sha256:o}),s=l=>l.reduce((u,d)=>u+d.length,0);return{...a,every:l=>{const u=a.every?.(l)??l,d=s(u.stack)+s(u.alternateStack);return u.metrics.maxMemoryUsage<d&&(u.metrics.maxMemoryUsage=d),u},operations:{...a.operations,[It.OP_EVAL]:Yu,[It.OP_POW]:mr(m(vo(t)))}}},Pr=(e=!0)=>vn(Zu(e)),ju=(e=!0)=>vn(bo(e)),Gu=(e=!0)=>vn(So(e)),Wu=It,Tr=e=>{if(e.length!==32||e.every(r=>r===0))return!1;const t=[255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,186,174,220,230,175,72,160,59,191,210,94,140,208,54,65,64],n=e.findIndex((r,i)=>r!==t[i]);return n===-1||e[n]<t[n]};var ue;(function(e){e.childIndexExceedsMaximum="HD node derivation error: child index exceeds maximum (4294967295).",e.requiresZeroDepthNode="HD node derivation error: absolute derivation requires an HD node with a depth of 0.",e.hardenedDerivationRequiresPrivateNode="HD node derivation error: derivation for hardened child indexes (indexes greater than or equal to 2147483648) requires an HD private node.",e.invalidAbsoluteDerivationPath=`HD node derivation error: invalid absolute derivation path; path must begin with "m" or "M" and contain only positive child index numbers, separated by forward slashes ("/"), with zero or one apostrophe ("'") after each child index number.`,e.invalidRelativeDerivationPath=`HD node derivation error: invalid relative derivation path; path must contain only positive child index numbers, separated by forward slashes ("/"), with zero or one apostrophe ("'") after each child index number.`,e.invalidDerivedKey="HD node derivation error: an astronomically rare HMAC-SHA512 result produced an invalid Secp256k1 key.",e.invalidPrivateDerivationPrefix='HD node derivation error: private derivation paths must begin with "m".',e.invalidPublicDerivationPrefix='HD node derivation error: public derivation paths must begin with "M".'})(ue||(ue={}));var re;(function(e){e.incorrectLength="HD key decoding error: length is incorrect (must encode 82 bytes).",e.invalidChecksum="HD key decoding error: checksum is invalid.",e.invalidPublicKey="HD key decoding error: the public key for this HD public node is not a valid Secp256k1 public key.",e.invalidPrivateKey="HD key decoding error: the key for this HD private node is not a valid Secp256k1 private key.",e.missingPrivateKeyPaddingByte="HD key decoding error: version indicates a private key, but the key data is missing a padding byte.",e.privateKeyExpected="HD key decoding error: expected an HD private key, but encountered an HD public key.",e.publicKeyExpected="HD key decoding error: expected an HD public key, but encountered an HD private key.",e.unknownCharacter="HD key decoding error: key includes a non-base58 character.",e.unknownVersion="HD key decoding error: key uses an unknown version.",e.zeroDepthWithNonZeroChildIndex="HD key decoding error: key encodes a depth of zero with a non-zero child index.",e.zeroDepthWithNonZeroParentFingerprint="HD key decoding error: key encodes a depth of zero with a non-zero parent fingerprint."})(re||(re={}));var Pe;(function(e){e.invalidChainCodeLength="HD key encoding error: invalid chain code length. Chain code must be 32 bytes.",e.invalidChildDepth="HD key encoding error: invalid child depth. Child depth must be between 0 and 255 (inclusive).",e.invalidChildIndex="HD key encoding error: invalid child index. Child index must be between 0 and 4294967295 (inclusive).",e.invalidParentFingerprintLength="HD key encoding error: invalid parent fingerprint length. Parent fingerprint must be 4 bytes.",e.invalidPrivateKeyLength="HD key encoding error: invalid private key length. Secp256k1 private keys must be 32 bytes.",e.invalidPublicKeyLength="HD key encoding error: invalid public key length. Public key must be 33 bytes (compressed).",e.invalidPublicKey="HD key encoding error: the public key for this HD public node is not a valid Secp256k1 public key.",e.zeroDepthWithNonZeroChildIndex="HD key encoding error: attempted to encode a zero depth key with a non-zero child index.",e.zeroDepthWithNonZeroParentFingerprint="HD key encoding error: attempted to encode a zero depth key with a non-zero parent fingerprint."})(Pe||(Pe={}));const Cr=Uint8Array.from([0,0,0,0]),Xu=fr("Bitcoin seed"),Qu=(e,{assumeValidity:t,crypto:n={sha512:Ge},hmacSha512Key:r=Xu,throwErrors:i=!0}={})=>{const o=_r(r,e,n.sha512),a=o.slice(0,32),s=o.slice(32),l=0,u=0,d=Cr.slice(),p=t??Tr(a);if(i&&!p)throw new Error(ue.invalidDerivedKey);return p?{chainCode:s,childIndex:u,depth:l,parentFingerprint:d,privateKey:a}:{chainCode:s,childIndex:u,depth:l,invalidMaterial:a,parentFingerprint:d}},Ju=(e,{crypto:t={ripemd160:ae,secp256k1:F,sha256:K}}={})=>{const n=t.secp256k1.derivePublicKeyCompressed(e.privateKey);return typeof n=="string"?n:t.ripemd160.hash(t.sha256.hash(n))},el=(e,{crypto:t={ripemd160:ae,sha256:K}}={})=>t.ripemd160.hash(t.sha256.hash(e.publicKey));var ye;(function(e){e[e.mainnetPrivateKey=76066276]="mainnetPrivateKey",e[e.mainnetPublicKey=76067358]="mainnetPublicKey",e[e.testnetPrivateKey=70615956]="testnetPrivateKey",e[e.testnetPublicKey=70617039]="testnetPublicKey"})(ye||(ye={}));const Oo=e=>e===ye.mainnetPublicKey||e===ye.testnetPublicKey,tl=e=>e===ye.mainnetPrivateKey||e===ye.testnetPrivateKey,nl=(e,{crypto:t={secp256k1:F,sha256:K}}={})=>{const n=ns(e);if(typeof n=="string")return x(re.unknownCharacter,n);if(n.length!==82)return x(re.incorrectLength,`Length: ${n.length}.`);const r=n.slice(0,78),i=n.slice(78),o=t.sha256.hash(t.sha256.hash(r));if(!i.every((b,w)=>b===o[w]))return x(re.invalidChecksum,`Encoded: ${P(i)}; computed: ${P(o.slice(0,4))}.`);const a=4,s=5,l=9,u=13,d=45,p=new DataView(n.buffer,n.byteOffset,n.byteLength),h=p.getUint32(0,!1),g=p.getUint8(a),y=n.slice(s,l),v=p.getUint32(l,!1),C=n.slice(u,d),T=n.slice(d,78),k=tl(h);if(k&&T[0]!==0)return re.missingPrivateKeyPaddingByte;if(k){const b=T.slice(1);return{node:Tr(b)?{chainCode:C,childIndex:v,depth:g,parentFingerprint:y,privateKey:b}:{chainCode:C,childIndex:v,depth:g,invalidMaterial:b,parentFingerprint:y},version:h}}if(!Oo(h))return x(re.unknownVersion,`Version: ${h}`);const S=T;return{node:t.secp256k1.validatePublicKey(S)?{chainCode:C,childIndex:v,depth:g,parentFingerprint:y,publicKey:S}:{chainCode:C,childIndex:v,depth:g,invalidMaterial:S,parentFingerprint:y},version:h}},xo=(e,{crypto:t={secp256k1:F,sha256:K}}={})=>{const n=nl(e,{crypto:t});if(typeof n=="string")return n;const{node:r,version:i}=n;if(r.depth===0){if(r.childIndex!==0)return x(re.zeroDepthWithNonZeroChildIndex,`Child index: ${r.childIndex}.`);if(!dr(r.parentFingerprint,Cr))return x(re.zeroDepthWithNonZeroParentFingerprint,`Parent fingerprint: ${r.parentFingerprint.join(",")}.`)}const o=Oo(i);return"invalidMaterial"in r?o?x(re.invalidPublicKey,`Invalid public key: ${P(r.invalidMaterial)}.`):x(re.invalidPrivateKey):{network:i===ye.mainnetPrivateKey||i===ye.mainnetPublicKey?"mainnet":"testnet",node:r}},Po=(e,{crypto:t={secp256k1:F,sha256:K}}={})=>{const n=xo(e,{crypto:t});if(typeof n=="string")return n;const{network:r,node:i}=n;return"publicKey"in i?re.privateKeyExpected:{network:r,node:i}},To=(e,{crypto:t={secp256k1:F,sha256:K}}={})=>{const n=xo(e,{crypto:t});if(typeof n=="string")return n;const{network:r,node:i}=n;return"privateKey"in i?re.publicKeyExpected:{network:r,node:i}},rl=({version:e,keyParameters:t,throwErrors:n=!0})=>{if(t.node.depth===0){if(t.node.childIndex!==0)return x(Pe.zeroDepthWithNonZeroChildIndex,`Child index: ${t.node.childIndex}.`,n);if(!dr(t.node.parentFingerprint,Cr))return x(Pe.zeroDepthWithNonZeroParentFingerprint,`Parent fingerprint: ${t.node.parentFingerprint.join(",")}.`,n)}if(t.node.chainCode.length!==32)return x(Pe.invalidChainCodeLength,`Chain code length: ${t.node.chainCode.length}.`,n);if(t.node.parentFingerprint.length!==4)return x(Pe.invalidParentFingerprintLength,`Parent fingerprint length: ${t.node.parentFingerprint.length}.`,n);if(t.node.depth<0||t.node.depth>255)return x(Pe.invalidChildDepth,`Depth: ${t.node.depth}.`,n);const r=Uint8Array.of(t.node.depth);if(t.node.childIndex<0||t.node.childIndex>4294967295)return x(Pe.invalidChildIndex,`Child index: ${t.node.childIndex}.`,n);const i=yn(t.node.childIndex);return Ee([e,r,t.node.parentFingerprint,i,t.node.chainCode])},il=(e,{throwErrors:t=!0}={})=>{const n=yn(e.network==="mainnet"?ye.mainnetPrivateKey:ye.testnetPrivateKey);if(e.node.privateKey.length!==32)return x(Pe.invalidPrivateKeyLength,`Private key length: ${e.node.privateKey.length}.`,t);const r=rl({keyParameters:e,throwErrors:t,version:n});if(typeof r=="string")return r;const i=Uint8Array.of(0);return Ee([r,i,e.node.privateKey])},ol=(e,{crypto:t={sha256:K}}={})=>{const r=t.sha256.hash(t.sha256.hash(e)).slice(0,4);return ts(Ee([e,r]))},al=(e,{crypto:t={sha256:K},throwErrors:n=!0}={})=>{const r=il(e,{throwErrors:n});return typeof r=="string"?r:{hdPrivateKey:ol(r,{crypto:t})}},sl=(e,t,{crypto:n={ripemd160:ae,secp256k1:F,sha256:K,sha512:Ge},throwErrors:r=!0,returnInvalidNodes:i=!1}={})=>{if(t>4294967295)return x(ue.childIndexExceedsMaximum,`Child index: ${t}.`,r);const a=Ju(e,{crypto:n}),s=a.slice(0,4),l=e.depth+1,d=t>=2147483648,p=d?e.privateKey:n.secp256k1.derivePublicKeyCompressed(e.privateKey),h=Uint8Array.from([...d?[0]:[],...p,...yn(t)]),g=_r(e.chainCode,h,n.sha512),y=32,v=g.slice(0,y),C=g.slice(y),T=n.secp256k1.addTweakPrivateKey(e.privateKey,v);if(typeof T=="string"){const k=x(ue.invalidDerivedKey,`Invalid child index: ${t}.`,r);return i?{chainCode:C,childIndex:t,depth:l,invalidMaterial:v,parentFingerprint:s,parentIdentifier:a}:k}return{chainCode:C,childIndex:t,depth:l,parentFingerprint:s,parentIdentifier:a,privateKey:T}},cl=(e,t,{crypto:n={ripemd160:ae,secp256k1:F,sha256:K,sha512:Ge},returnInvalidNodes:r=!1,throwErrors:i=!0}={})=>{if(t>=2147483648)return x(ue.hardenedDerivationRequiresPrivateNode,`Requested index: ${t}.`,i);const a=el(e,{crypto:n}),s=a.slice(0,4),l=e.depth+1,u=Uint8Array.from([...e.publicKey,...yn(t)]),d=_r(e.chainCode,u,n.sha512),p=32,h=d.slice(0,p),g=d.slice(p),y=n.secp256k1.addTweakPublicKeyCompressed(e.publicKey,h);if(typeof y=="string"){const v=x(ue.invalidDerivedKey,`Invalid child index: ${t}.`,i);return r?{chainCode:g,childIndex:t,depth:l,invalidMaterial:h,parentFingerprint:s,parentIdentifier:a}:v}return{chainCode:g,childIndex:t,depth:l,parentFingerprint:s,parentIdentifier:a,publicKey:y}},Er=(e,t,{crypto:n={ripemd160:ae,secp256k1:F,sha256:K,sha512:Ge},throwErrors:r=!0}={})=>{if(t==="")return e;if(!/^(?:[0-9]+'?)(?:\/[0-9]+'?)*$/u.test(t))return x(ue.invalidRelativeDerivationPath,`Invalid path: "${t}".`,r);const o=t.split("/"),a="privateKey"in e,s=10,l=2147483648,u=o.map(d=>d.endsWith("'")?parseInt(d.slice(0,-1),s)+l:parseInt(d,s));return a?u.reduce((d,p)=>typeof d=="string"?d:sl(d,p,{crypto:n,throwErrors:r}),e):u.reduce((d,p)=>typeof d=="string"?d:cl(d,p,{crypto:n,throwErrors:r}),e)},ul=(e,t,{crypto:n={ripemd160:ae,secp256k1:F,sha256:K,sha512:Ge},throwErrors:r=!0}={})=>{if(e.depth!==0)return x(ue.requiresZeroDepthNode,`Depth of provided HD node: ${e.depth}.`,r);if(!/^[mM](?:\/[0-9]+'?)*$/u.test(t))return x(ue.invalidAbsoluteDerivationPath,`Invalid path: "${t}".`,r);const o=t.split("/"),a="privateKey"in e;if(a&&o[0]!=="m")return x(ue.invalidPrivateDerivationPrefix,`Invalid path: "${t}".`,r);if(!a&&o[0]!=="M")return x(ue.invalidPublicDerivationPrefix,`Invalid path: "${t}".`,r);if(o.length===1)return e;const s=o.slice(1).join("/");return Er(e,s,{crypto:n,throwErrors:r})};var Zr;(function(e){e.cannotCrackHardenedDerivation="HD node cracking error: cannot crack an HD parent node using hardened child node."})(Zr||(Zr={}));var Le;(function(e){e.opcode="opcode",e.variable="variable",e.script="script"})(Le||(Le={}));var xt;(function(e){e.unknown="unknown",e.variable="variable",e.script="script"})(xt||(xt={}));const Xt=e=>({startColumn:e.startColumn,startLineNumber:e.startLineNumber}),Qt=e=>({endColumn:e.endColumn,endLineNumber:e.endLineNumber}),ll=(e,t={endColumn:0,endLineNumber:0,startColumn:0,startLineNumber:0})=>{const r=e.length<2?e.length===1?e[0]:t:e.reduce((i,o)=>({...o.endLineNumber>i.endLineNumber||o.endLineNumber===i.endLineNumber&&o.endColumn>i.endColumn?Qt(o):Qt(i),...o.startLineNumber<i.startLineNumber||o.startLineNumber===i.startLineNumber&&o.startColumn<i.startColumn?Xt(o):Xt(i)}),e[0]);return{...Qt(r),...Xt(r)}},Co=e=>e.reduce((t,n)=>{switch(n.type){case"error":return[...t,{error:n.value,...n.missingIdentifier===void 0?{}:{missingIdentifier:n.missingIdentifier,owningEntity:n.owningEntity},range:n.range}];case"push":case"evaluation":return[...t,...Co(n.value)];default:return t}},[]),Eo=(e,t="; ")=>e.map(n=>`[${n.range.startLineNumber}, ${n.range.startColumn}] ${n.error}`).join(t);function J(e){if(!(this instanceof J))return new J(e);this._=e}const Be=J.prototype;function Ie(e,t){return{expected:[],furthest:-1,index:e,status:!0,value:t}}function xn(e,t){return t=[t],{expected:t,furthest:e,index:-1,status:!1,value:null}}function at(e,t){return!t||e.furthest>t.furthest?e:{expected:e.furthest===t.furthest?dl(e.expected,t.expected):t.expected,furthest:t.furthest,index:e.index,status:e.status,value:e.value}}function Bo(e,t){const n=e.slice(0,t).split(`
`),r=n.length;return{column:n[n.length-1].length+1,line:r,offset:t}}function dl(e,t){const n={};for(let i=0;i<e.length;i++)n[e[i]]=!0;for(let i=0;i<t.length;i++)n[t[i]]=!0;const r=[];for(const i in n)r.push(i);return r.sort(),r}function pl(e){const t=String(e);return t.slice(t.lastIndexOf("/")+1)}function hl(e){return RegExp(`^(?:${e.source})`,pl(e))}function Pn(...e){const t=[].slice.call(e),n=t.length;return J(function(r,i){let o;const a=new Array(n);for(let s=0;s<n;s+=1){if(o=at(t[s]._(r,i),o),!o.status)return o;a[s]=o.value,i=o.index}return at(Ie(i,a),o)})}function Br(...e){const t=[].slice.call(e),n=t.pop();return Pn.apply(null,t).map(function(r){return n.apply(null,r)})}function ml(e){const t={};for(const n in e)(function(r){const i=function(){return e[r](t)};t[r]=Ao(i)})(n);return t}function Io(...e){const t=[].slice.call(e);return J(function(n,r){let i;for(let o=0;o<t.length;o+=1)if(i=at(t[o]._(n,r),i),i.status)return i;return i})}function wo(e,t){return $o(e,t).or(Gn([]))}function $o(e,t){const n=t.then(e).many();return Br(e,n,function(r,i){return[r].concat(i)})}Be.parse=function(e){const t=this.skip(gl)._(e,0);return t.status?{status:!0,value:t.value}:{expected:t.expected,index:Bo(e,t.furthest),status:!1}};Be.or=function(e){return Io(this,e)};Be.then=function(e){return Pn(this,e).map(function(t){return t[1]})};Be.many=function(){const e=this;return J(function(t,n){const r=[];let i;for(;;)if(i=at(e._(t,n),i),i.status){if(n===i.index)throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser that can accept zero characters is usually the cause");n=i.index,r.push(i.value)}else return at(Ie(n,r),i)})};Be.map=function(e){const t=this;return J(function(n,r){const i=t._(n,r);return i.status?at(Ie(i.index,e(i.value)),i):i})};Be.skip=function(e){return Pn(this,e).map(function(t){return t[0]})};Be.node=function(e){return Br(Wn,this,Wn,function(t,n,r){return{end:r,name:e,start:t,value:n}})};Be.sepBy=function(e){return wo(this,e)};Be.desc=function(e){e=[e];const t=this;return J(function(n,r){const i=t._(n,r);return i.status||(i.expected=e),i})};function fl(e){const t=`'${e}'`;return J(function(n,r){const i=r+e.length,o=n.slice(r,i);return o===e?Ie(i,o):xn(r,t)})}function Ir(e,t=0){const n=hl(e),r=String(e);return J(function(i,o){const a=n.exec(i.slice(o));if(a){const s=a[0],l=a[t];return Ie(o+s.length,l)}return xn(o,r)})}function Gn(e){return J(function(t,n){return Ie(n,e)})}function Ao(e){const t=J(function(n,r){return t._=e()._,t._(n,r)});return t}const Wn=J(function(e,t){return Ie(t,Bo(e,t))}),gl=J(function(e,t){return t<e.length?xn(t,"EOF"):Ie(t,null)}),_l=Ir(/\s*/u).desc("optional whitespace"),yl=Ir(/\s+/u).desc("whitespace"),$={alt:Io,createLanguage:ml,index:Wn,lazy:Ao,makeFailure:xn,makeSuccess:Ie,of:Gn,optWhitespace:_l,regexp:Ir,sepBy:wo,sepBy1:$o,seq:Pn,seqMap:Br,string:fl,succeed:Gn,whitespace:yl},bl=$.createLanguage({script:e=>$.seqMap($.optWhitespace,e.expression.sepBy($.optWhitespace),$.optWhitespace,(t,n)=>n).node("Script"),expression:e=>$.alt(e.comment,e.push,e.evaluation,e.utf8,e.binary,e.hex,e.bigint,e.identifier),comment:e=>$.alt(e.singleLineComment,e.multiLineComment).node("Comment"),singleLineComment:()=>$.seqMap($.string("//").desc("the start of a single-line comment ('//')"),$.regexp(/[^\n]*/u),(e,t)=>t.trim()),multiLineComment:()=>$.seqMap($.string("/*").desc("the start of a multi-line comment ('/*')"),$.regexp(/[\s\S]*?\*\//u).desc("the end of this multi-line comment ('*/')"),(e,t)=>t.slice(0,-2).trim()),push:e=>$.seqMap($.string("<").desc("the start of a push statement ('<')"),e.script,$.string(">").desc("the end of this push statement ('>')"),(t,n)=>n).node("Push"),evaluation:e=>$.seqMap($.string("$").desc("the start of an evaluation ('$')"),$.string("(").desc("the opening parenthesis of this evaluation ('(')"),e.script,$.string(")").desc("the closing parenthesis of this evaluation (')')"),(t,n,r)=>r).node("Evaluation"),identifier:()=>$.regexp(/[a-zA-Z_][.a-zA-Z0-9_-]*/u).desc("a valid identifier").node("Identifier"),utf8:()=>$.alt($.seqMap($.string('"').desc('a double quote (")'),$.regexp(/[^"]*/u),$.string('"').desc('a closing double quote (")'),(e,t)=>t),$.seqMap($.string("'").desc("a single quote (')"),$.regexp(/[^']*/u),$.string("'").desc("a closing single quote (')"),(e,t)=>t)).node("UTF8Literal"),hex:()=>$.seqMap($.string("0x").desc("a hex literal ('0x...')"),$.regexp(/[0-9a-f]_*(?:_*[0-9a-f]_*[0-9a-f]_*)*[0-9a-f]/iu).desc("a valid hexadecimal string"),(e,t)=>t).node("HexLiteral"),binary:()=>$.seqMap($.string("0b").desc("a binary literal ('0b...')"),$.regexp(/[01]+(?:[01_]*[01]+)*/iu).desc("a string of binary digits"),(e,t)=>t).node("BinaryLiteral"),bigint:()=>$.regexp(/-?[0-9]+(?:[0-9_]*[0-9]+)*/u).desc("an integer literal").node("BigIntLiteral")}),kl=e=>bl.script.parse(rs(e)),Jt=e=>({bytecode:Uint8Array.of(),range:e}),Sl=e=>e.error!==void 0?e.error:e.controlStack.length!==0?"The CashAssembly internal evaluation completed with a non-empty control stack.":e.stack.length!==1?"The CashAssembly internal evaluation completed with an unexpected number of items on the stack (must be exactly 1).":!0,Xn=(e,t,n)=>{const r=e.map(o=>{switch(o.type){case"bytecode":return{bytecode:o.value,range:o.range};case"push":{const a=Xn(o.value,t,n);return{bytecode:is(a.bytecode),...a.errors===void 0?void 0:{errors:a.errors},push:a,range:o.range}}case"evaluation":{if(typeof t>"u"||typeof n>"u")return{errors:[{error:"Both a VM and a createAuthenticationProgram method are required to reduce evaluations.",range:o.range}],...Jt(o.range)};const a=Xn(o.value,t,n);if(a.errors!==void 0)return{...Jt(o.range),errors:a.errors,source:a,trace:[]};const s=t.debug(n(a.bytecode)),l=s[s.length-1],u=Sl(l),d=l.stack[l.stack.length-1];return{...typeof u=="string"?{bytecode:Uint8Array.of(),errors:[{error:`Failed to reduce evaluation: ${u}`,range:o.range}]}:{bytecode:d},range:o.range,source:a,trace:s}}case"comment":return{...Jt(o.range),comment:o.value};case"error":return{errors:[{error:`Tried to reduce a CashAssembly script with resolution errors: ${o.value}`,range:o.range}],...Jt(o.range)};default:throw new Error(`"${o.type}" is not a known segment type.`)}}),i=r.reduce((o,a)=>({bytecode:[...o.bytecode,a.bytecode],ranges:[...o.ranges,a.range],...o.errors!==void 0||a.errors!==void 0?{errors:[...o.errors??[],...a.errors??[]]}:void 0}),{bytecode:[],ranges:[]});return{...i.errors===void 0?void 0:{errors:i.errors},bytecode:Ee(i.bytecode),range:ll(i.ranges,e.length===0?void 0:e[0].range),script:r}},jr=e=>({endColumn:e.end.column,endLineNumber:e.end.line,startColumn:e.start.column,startLineNumber:e.start.line}),$n=e=>e.replace(/_/gu,""),Qn=(e,t)=>{const n=e.value.map(r=>{const i=jr(r);switch(r.name){case"Identifier":{const o=r.value,a=t(o);return a.status?{range:i,type:"bytecode",value:a.bytecode,...a.type===Le.opcode?{opcode:o}:a.type===Le.variable?{..."debug"in a?{debug:a.debug}:{},..."signature"in a?{signature:a.signature}:{},variable:o}:a.type===Le.script?{script:o,source:a.source}:{unknown:o}}:{..."debug"in a?{debug:a.debug}:{},..."recoverable"in a&&a.recoverable?{missingIdentifier:o,owningEntity:a.entityOwnership}:{},range:i,type:"error",value:a.error}}case"Push":return{range:i,type:"push",value:Qn(r.value,t)};case"Evaluation":return{range:i,type:"evaluation",value:Qn(r.value,t)};case"BigIntLiteral":return{literal:r.value,literalType:"BigIntLiteral",range:i,type:"bytecode",value:lt(BigInt($n(r.value)))};case"BinaryLiteral":return{literal:r.value,literalType:"BinaryLiteral",range:i,type:"bytecode",value:oc($n(r.value))};case"HexLiteral":return{literal:r.value,literalType:"HexLiteral",range:i,type:"bytecode",value:oe($n(r.value))};case"UTF8Literal":return{literal:r.value,literalType:"UTF8Literal",range:i,type:"bytecode",value:fr(r.value)};case"Comment":return{range:i,type:"comment",value:r.value};default:return{range:i,type:"error",value:`Unrecognized segment: ${r.name}`}}});return n.length===0?[{range:jr(e),type:"comment",value:""}]:n};var Pt;(function(e){e.currentBlockTime="current_block_time",e.currentBlockHeight="current_block_height",e.signingSerialization="signing_serialization"})(Pt||(Pt={}));const en=({data:e,configuration:t,identifier:n,matchingOperations:r,operationExample:i="operation_identifier",operationId:o,variableId:a,variableType:s})=>{if(r===void 0)return{error:`The "${a}" variable type can not be resolved because the "${s}" operation has not been included in this compiler's configuration.`,status:"error"};if(typeof r=="function")return r(n,e,t);if(o===void 0)return{error:`This "${a}" variable could not be resolved because this compiler's "${s}" operations require an operation identifier, e.g. '${a}.${i}'.`,status:"error"};const l=r[o];return l===void 0?{error:`The identifier "${n}" could not be resolved because the "${a}.${o}" operation is not available to this compiler.`,status:"error"}:l(n,e,t)},vl=({data:e,configuration:t,identifier:n})=>{const[r,i]=n.split(".");switch(r){case Pt.currentBlockHeight:return en({configuration:t,data:e,identifier:n,matchingOperations:t.operations?.currentBlockHeight,operationId:i,variableId:r,variableType:"currentBlockHeight"});case Pt.currentBlockTime:return en({configuration:t,data:e,identifier:n,matchingOperations:t.operations?.currentBlockTime,operationId:i,variableId:r,variableType:"currentBlockTime"});case Pt.signingSerialization:return en({configuration:t,data:e,identifier:n,matchingOperations:t.operations?.signingSerialization,operationExample:"version",operationId:i,variableId:r,variableType:"signingSerialization"});default:{const o=t.variables?.[r];return o===void 0?{status:"skip"}:en({configuration:t,data:e,identifier:n,operationId:i,variableId:r,...{AddressData:{matchingOperations:t.operations?.addressData,variableType:"addressData"},HdKey:{matchingOperations:t.operations?.hdKey,operationExample:"public_key",variableType:"hdKey"},Key:{matchingOperations:t.operations?.key,operationExample:"public_key",variableType:"key"},WalletData:{matchingOperations:t.operations?.walletData,variableType:"walletData"}}[o.type]})}}},Ol=e=>{const t="EOF",n=e.filter(s=>s!==t);n.length!==e.length&&n.push("the end of the script");const r=n.slice(0,n.length-1),i=n[n.length-1];return`Encountered unexpected input while parsing script. Expected ${n.length>=3?r.join(", ").concat(`, or ${i}`):n.length===2?n.join(" or "):i}.`},he=()=>({endColumn:0,endLineNumber:0,startColumn:0,startLineNumber:0}),xl=({configuration:e,data:t})=>[...t.bytecode===void 0?[]:Object.entries(t.bytecode).filter(([n])=>n.endsWith(".public_key")).reduce((n,[r,i])=>n.concat(e.secp256k1?.validatePublicKey(i)===!0?[]:[e.secp256k1===void 0?{error:`Could not validate compilation data: the public key provided for "${r}" could not be validated because the "secp256k1" property was not provided in the compiler configuration.`,range:he()}:{error:`Invalid compilation data detected: the public key provided for "${r}" is not a valid Secp256k1 public key.`,range:he()}]),[]),...t.keys?.privateKeys===void 0?[]:Object.entries(t.keys.privateKeys).reduce((n,[r,i])=>n.concat(Tr(i)?[]:[{error:`Invalid compilation data detected: the private key provided for the "${r}" variable is not a valid Secp256k1 private key.`,range:he()}]),[]),...t.hdKeys?.hdPrivateKeys===void 0?[]:Object.entries(t.hdKeys.hdPrivateKeys).reduce((n,[r,i])=>{const o=Po(i);return n.concat(typeof o=="string"?[{error:`Invalid compilation data detected: the HD private key provided for the "${r}" entity is not a valid HD private key. ${o}`,range:he()}]:[])},[]),...t.hdKeys?.hdPublicKeys===void 0?[]:Object.entries(t.hdKeys.hdPublicKeys).reduce((n,[r,i])=>{const o=To(i);return n.concat(typeof o=="string"?[{error:`Invalid compilation data detected: the HD public key provided for the "${r}" entity is not a valid HD public key. ${o}`,range:he()}]:[])},[])],nt=({data:e,configuration:t,scriptId:n})=>{const r=t.scripts[n];if(r===void 0)return{errorType:"parse",errors:[{error:`No script with an ID of "${n}" was provided in the compiler configuration.`,range:he()}],success:!1};if(t.sourceScriptIds?.includes(n)===!0)return{errorType:"parse",errors:[{error:`A circular dependency was encountered: script "${n}" relies on itself to be generated. (Source scripts: ${t.sourceScriptIds.join("  ")})`,range:he()}],success:!1};const i=t.sourceScriptIds===void 0?[n]:[...t.sourceScriptIds,n],o=xl({configuration:t,data:e});return o.length!==0?{errorType:"parse",errors:o,success:!1}:Tl({configuration:{...t,sourceScriptIds:i},data:e,script:r})},No=({data:e,configuration:t,identifier:n})=>{if(t.scripts[n]===void 0)return!1;const r=nt({configuration:t,data:e,scriptId:n});return r.success?r:`Compilation error in resolved script "${n}": ${Eo(r.errors)}`},Pl=({data:e,configuration:t})=>n=>{const r=t.opcodes?.[n];if(r!==void 0)return{bytecode:r,status:!0,type:Le.opcode};const i=vl({configuration:t,data:e,identifier:n});if(i.status!=="skip")return i.status==="error"?{..."debug"in i?{debug:i.debug}:{},error:i.error,...t.entityOwnership===void 0?{}:{entityOwnership:t.entityOwnership[n.split(".")[0]]},recoverable:"recoverable"in i,status:!1,type:xt.variable}:{..."debug"in i?{debug:i.debug}:{},bytecode:i.bytecode,..."signature"in i?{signature:i.signature}:{},status:!0,type:Le.variable};const o=No({configuration:t,data:e,identifier:n});return o!==!1?typeof o=="string"?{error:o,scriptId:n,status:!1,type:xt.script}:{bytecode:o.bytecode,source:o,status:!0,type:Le.script}:{error:`Unknown identifier "${n}".`,status:!1,type:xt.unknown}},Tl=({data:e,configuration:t,script:n})=>{const r=kl(n);if(!r.status)return{errorType:"parse",errors:[{error:Ol(r.expected),range:{endColumn:r.index.column,endLineNumber:r.index.line,startColumn:r.index.column,startLineNumber:r.index.line}}],success:!1};const i=Pl({configuration:t,data:e}),o=Qn(r.value,i),a=Co(o);if(a.length!==0)return{errorType:"resolve",errors:a,parse:r.value,resolve:o,success:!1};const s=Xn(o,t.vm,t.createAuthenticationProgram);return{...s.errors===void 0?{bytecode:s.bytecode,success:!0}:{errorType:"reduce",errors:s.errors,success:!1},parse:r.value,reduce:s,resolve:o}},Cl=(e,t,n)=>{if(t.compilationContext?.transaction.locktime!==void 0){if(n.unlockingScriptTimeLockTypes?.[e]==="height"&&t.compilationContext.transaction.locktime>=5e8)return{errorType:"parse",errors:[{error:`The script "${e}" requires a height-based locktime (less than 500,000,000), but this transaction uses a timestamp-based locktime ("${t.compilationContext.transaction.locktime}").`,range:he()}],success:!1};if(n.unlockingScriptTimeLockTypes?.[e]==="timestamp"&&t.compilationContext.transaction.locktime<5e8)return{errorType:"parse",errors:[{error:`The script "${e}" requires a timestamp-based locktime (greater than or equal to 500,000,000), but this transaction uses a height-based locktime ("${t.compilationContext.transaction.locktime}").`,range:he()}],success:!1}}if(t.compilationContext?.transaction.inputs[t.compilationContext.inputIndex]?.sequenceNumber!==void 0&&n.unlockingScriptTimeLockTypes?.[e]!==void 0&&t.compilationContext.transaction.inputs[t.compilationContext.inputIndex].sequenceNumber===4294967295)return{errorType:"parse",errors:[{error:`The script "${e}" requires a locktime, but this input's sequence number is set to disable transaction locktime (0xffffffff). This will cause the OP_CHECKLOCKTIMEVERIFY operation to error when the transaction is verified. To be valid, this input must use a sequence number that does not disable locktime.`,range:he()}],success:!1};const o=nt({configuration:n,data:t,scriptId:e});if(!o.success)return o;const a=n.unlockingScripts?.[e],s=a===void 0?void 0:n.lockingScriptTypes?.[a],l=s==="p2sh20"||s==="p2sh32",u=n.lockingScriptTypes?.[e];if(u==="p2sh20"||u==="p2sh32"){const p=nt({configuration:{...n,scripts:{p2sh20Locking:"OP_HASH160 <$(<lockingBytecode> OP_HASH160)> OP_EQUAL",p2sh32Locking:"OP_HASH256 <$(<lockingBytecode> OP_HASH256)> OP_EQUAL"},variables:{lockingBytecode:{type:"AddressData"}}},data:{bytecode:{lockingBytecode:o.bytecode}},scriptId:u==="p2sh20"?"p2sh20Locking":"p2sh32Locking"});return p.success?{...o,bytecode:p.bytecode,transformed:u==="p2sh20"?"p2sh20-locking":"p2sh32-locking"}:p}if(l){const p=nt({configuration:n,data:t,scriptId:a});if(!p.success)return p;const h=nt({configuration:{...n,scripts:{p2shUnlocking:"unlockingBytecode <lockingBytecode>"},variables:{lockingBytecode:{type:"AddressData"},unlockingBytecode:{type:"AddressData"}}},data:{bytecode:{lockingBytecode:p.bytecode,unlockingBytecode:o.bytecode}},scriptId:"p2shUnlocking"});return{...o,bytecode:h.bytecode,transformed:s==="p2sh20"?"p2sh20-unlocking":"p2sh32-unlocking"}}return o};var z;(function(e){e[e.defaultScenarioAddressIndex=0]="defaultScenarioAddressIndex",e.defaultScenarioBytecode="",e[e.defaultScenarioCurrentBlockHeight=2]="defaultScenarioCurrentBlockHeight",e[e.defaultScenarioCurrentBlockTime=1231469665]="defaultScenarioCurrentBlockTime",e.defaultScenarioInputOutpointTransactionHash="0000000000000000000000000000000000000000000000000000000000000001",e.defaultScenarioOutputTokenCategory="0000000000000000000000000000000000000000000000000000000000000002",e[e.defaultScenarioInputSequenceNumber=0]="defaultScenarioInputSequenceNumber",e.defaultScenarioOutputLockingBytecode="6a076c696261757468",e[e.defaultScenarioOutputValueSatoshis=0]="defaultScenarioOutputValueSatoshis",e[e.defaultScenarioTransactionLocktime=0]="defaultScenarioTransactionLocktime",e[e.defaultScenarioTransactionVersion=2]="defaultScenarioTransactionVersion",e[e.hdKeyAddressOffset=0]="hdKeyAddressOffset",e.hdKeyHdPublicKeyDerivationPath="",e.hdKeyPrivateDerivationPath="i",e.scenarioBytecodeScriptPrefix="_scenario."})(z||(z={}));const ht=(e,t)=>(n,r,i)=>{for(const o of e){const a=o(n,r,i);if(a.status!=="skip")return a}return t(n,r,i)},H=({canBeSkipped:e,dataProperties:t,configurationProperties:n,operation:r})=>(i,o,a)=>{for(const s of n)if(a[s]===void 0)return e?{status:"skip"}:{error:`Cannot resolve "${i}" - the "${s}" property was not provided in the compiler configuration.`,status:"error"};for(const s of t)if(o[s]===void 0)return e?{status:"skip"}:{error:`Cannot resolve "${i}" - the "${s}" property was not provided in the compilation data.`,status:"error"};return r(i,o,a)},mt=H({canBeSkipped:!0,configurationProperties:[],dataProperties:["bytecode"],operation:(e,t)=>{const n=t.bytecode[e];return n!==void 0?{bytecode:n,status:"success"}:{status:"skip"}}}),Ho=({addressIndex:e,entityId:t,entityHdPrivateKey:n,configuration:r,hdKey:i,identifier:o})=>{const a=i.addressOffset??z.hdKeyAddressOffset,s=i.privateDerivationPath??z.hdKeyPrivateDerivationPath,l=e+a;if(!/^(?:m|i|[0-9]+)'?(?:\/(?:[0-9]+|i)'?)*$/u.test(s))return{error:`Could not generate "${o}" - the path "${s}" is not a valid "privateDerivationPath".`,status:"error"};const d=gr(Po(n,{crypto:r})),p=s.replace("i",l.toString()),g=(p.includes("m")?ul:Er)(d.node,p,{crypto:r,throwErrors:!1});return typeof g=="string"?{error:`Could not generate "${o}" - the path "${p}" could not be derived for entity "${t}": ${g}`,status:"error"}:{bytecode:g.privateKey,status:"success"}},Lo=(e,t)=>({error:`Identifier "${e}" refers to an HdKey, but the "entityOwnership" for "${t}" is not available in this compiler configuration.`,status:"error"}),Uo=e=>({error:`Identifier "${e}" refers to an HdKey, but "hdKeys.addressIndex" was not provided in the compilation data.`,status:"error"}),Do=({configuration:e,hdKeys:t,identifier:n})=>{const{addressIndex:r,hdPrivateKeys:i}=t,[o]=n.split("."),a=e.entityOwnership[o];if(a===void 0)return Lo(n,o);if(r===void 0)return Uo(n);const s=i===void 0?void 0:i[a];if(s===void 0)return{error:`Identifier "${n}" refers to an HdKey owned by "${a}", but an HD private key for this entity (or an existing signature) was not provided in the compilation data.`,recoverable:!0,status:"error"};const l=e.variables[o];return Ho({addressIndex:r,configuration:e,entityHdPrivateKey:s,entityId:a,hdKey:l,identifier:n})},Ko=({targetScriptId:e,data:t,configuration:n})=>{const r=n.scripts[e],i=No({configuration:n,data:t,identifier:e});return r===void 0||i===!1?!1:typeof i=="string"?{error:i,status:"error"}:i.bytecode},Tn=({data:e,configuration:t,identifier:n,sourceScriptIds:r,unlockingScripts:i})=>{const o=r[r.length-1];if(o===void 0)return{error:`Identifier "${n}" requires a signing serialization, but "coveredBytecode" cannot be determined because the compiler configuration's "sourceScriptIds" is empty.`,status:"error"};const a=i[o];if(a===void 0)return{error:`Identifier "${n}" requires a signing serialization, but "coveredBytecode" cannot be determined because "${o}" is not present in the compiler configuration's "unlockingScripts".`,status:"error"};const s=Ko({configuration:t,data:e,targetScriptId:a});return s===!1?{error:`Identifier "${n}" requires a signing serialization that covers an unknown locking script, "${a}".`,status:"error"}:s},El=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["bytecode"],operation:(e,t)=>{const n=t.bytecode[e];return n!==void 0?{bytecode:n,status:"success"}:{error:`Identifier "${e}" refers to an AddressData, but "${e}" was not provided in the CompilationData "bytecode".`,recoverable:!0,status:"error"}}}),Bl=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["bytecode"],operation:(e,t)=>{const n=t.bytecode[e];return n!==void 0?{bytecode:n,status:"success"}:{error:`Identifier "${e}" refers to a WalletData, but "${e}" was not provided in the CompilationData "bytecode".`,recoverable:!0,status:"error"}}}),Il=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["currentBlockTime"],operation:(e,t)=>({bytecode:zt(t.currentBlockTime),status:"success"})}),wl=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["currentBlockHeight"],operation:(e,t)=>({bytecode:lt(BigInt(t.currentBlockHeight)),status:"success"})}),$l=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>{const{correspondingOutput:n}=yi(t.compilationContext);return n===void 0?{bytecode:Uint8Array.of(),status:"success"}:{bytecode:n,status:"success"}}}),Al=H({canBeSkipped:!1,configurationProperties:["sha256"],dataProperties:["compilationContext"],operation:(e,t,n)=>{const{correspondingOutput:r}=yi(t.compilationContext);return r===void 0?{bytecode:Uint8Array.of(),status:"success"}:{bytecode:n.sha256.hash(n.sha256.hash(r)),status:"success"}}}),Mo=e=>H({canBeSkipped:!1,configurationProperties:["sourceScriptIds","unlockingScripts"],dataProperties:["compilationContext"],operation:(t,n,r)=>{const{unlockingScripts:i,sourceScriptIds:o}=r,a=Tn({configuration:r,data:n,identifier:t,sourceScriptIds:o,unlockingScripts:i});return"error"in a?a:{bytecode:e?os(BigInt(a.length)):a,status:"success"}}}),Nl=Mo(!1),Hl=Mo(!0),Ll=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:zt(t.compilationContext.transaction.locktime),status:"success"})}),Ul=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:zt(t.compilationContext.transaction.inputs[t.compilationContext.inputIndex].outpointIndex),status:"success"})}),Dl=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:t.compilationContext.transaction.inputs[t.compilationContext.inputIndex].outpointTransactionHash,status:"success"})}),Kl=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:as(t.compilationContext.sourceOutputs[t.compilationContext.inputIndex].valueSatoshis),status:"success"})}),Ml=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:zt(t.compilationContext.transaction.inputs[t.compilationContext.inputIndex].sequenceNumber),status:"success"})}),Rl=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:bi(t.compilationContext.transaction.inputs),status:"success"})}),zl=H({canBeSkipped:!1,configurationProperties:["sha256"],dataProperties:["compilationContext"],operation:(e,t,n)=>({bytecode:n.sha256.hash(n.sha256.hash(bi(t.compilationContext.transaction.inputs))),status:"success"})}),Fl=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:ki(t.compilationContext.transaction.outputs),status:"success"})}),Vl=H({canBeSkipped:!1,configurationProperties:["sha256"],dataProperties:["compilationContext"],operation:(e,t,n)=>({bytecode:n.sha256.hash(n.sha256.hash(ki(t.compilationContext.transaction.outputs))),status:"success"})}),ql=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:Si(t.compilationContext.transaction.inputs),status:"success"})}),Yl=H({canBeSkipped:!1,configurationProperties:["sha256"],dataProperties:["compilationContext"],operation:(e,t,n)=>({bytecode:n.sha256.hash(n.sha256.hash(Si(t.compilationContext.transaction.inputs))),status:"success"})}),Zl=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:zt(t.compilationContext.transaction.version),status:"success"})}),jl=ht([mt],H({canBeSkipped:!1,configurationProperties:["secp256k1"],dataProperties:["keys"],operation:(e,t,n)=>{const{keys:r}=t,{secp256k1:i}=n,{privateKeys:o}=r,[a]=e.split(".");return o?.[a]!==void 0?{bytecode:i.derivePublicKeyCompressed(o[a]),status:"success"}:{error:`Identifier "${e}" refers to a public key, but no public or private keys for "${a}" were provided in the compilation data.`,recoverable:!0,status:"error"}}})),Gl=ht([mt],H({canBeSkipped:!1,configurationProperties:["entityOwnership","ripemd160","secp256k1","sha256","sha512","variables"],dataProperties:["hdKeys"],operation:(e,t,n)=>{const{hdKeys:r}=t,{hdPrivateKeys:i,addressIndex:o,hdPublicKeys:a}=r,[s]=e.split("."),l=n.entityOwnership[s];if(l===void 0)return Lo(e,s);if(o===void 0)return Uo(e);const u=i===void 0?void 0:i[l],d=n.variables[s];if(u!==void 0){const w=Ho({addressIndex:o,configuration:n,entityHdPrivateKey:u,entityId:l,hdKey:d,identifier:e});return w.status==="error"?w:{bytecode:n.secp256k1.derivePublicKeyCompressed(w.bytecode),status:"success"}}const p=a===void 0?void 0:a[l];if(p===void 0)return{error:`Identifier "${e}" refers to an HdKey owned by "${l}", but an HD private key or HD public key for this entity was not provided in the compilation data.`,recoverable:!0,status:"error"};const h=d.addressOffset??z.hdKeyAddressOffset,g=d.privateDerivationPath??z.hdKeyPrivateDerivationPath,y=d.hdPublicKeyDerivationPath??z.hdKeyHdPublicKeyDerivationPath,v=d.publicDerivationPath??g.replace("m/","");if(y!==""&&!/^(?:m|[0-9]+)'?(?:\/(?:[0-9]+'?))*$/u.test(y))return{error:`Could not generate "${e}" - "hdPublicKeyDerivationPath" ("${y}") must be a fixed (no "i" characters), valid absolute derivation path.`,status:"error"};const T=y===""?v:`${y}/${v}`;if(g!==T)return{error:`Could not generate "${e}" - "privateDerivationPath" ("${g}") is expected to be the combination of "hdPublicKeyDerivationPath" and "publicDerivationPath": "${T}".`,status:"error"};const k=gr(To(p,{crypto:n})),O=o+h,S=v.replace("i",O.toString()),M=y.split("/").length-1;if(y!==""&&k.node.depth!==M)return{error:`Could not generate "${e}" - the HD public key derivation path ("${y}") indicates an expected depth of ${M}, but the provided HD public key has a depth of ${k.node.depth}.`,status:"error"};const b=Er(k.node,S,{crypto:n,throwErrors:!1});return typeof b=="string"?{error:`Could not generate "${e}" - the path "${S}" could not be derived for entity "${l}": ${b}`,status:"error"}:{bytecode:b.publicKey,status:"success"}}})),tn={addressData:El,currentBlockHeight:wl,currentBlockTime:Il,hdKey:{public_key:Gl},key:{public_key:jl},signingSerialization:{corresponding_output:$l,corresponding_output_hash:Al,covered_bytecode:Nl,covered_bytecode_length:Hl,locktime:Ll,outpoint_index:Ul,outpoint_transaction_hash:Dl,output_value:Kl,sequence_number:Ml,transaction_outpoints:Rl,transaction_outpoints_hash:zl,transaction_outputs:Fl,transaction_outputs_hash:Vl,transaction_sequence_numbers:ql,transaction_sequence_numbers_hash:Yl,version:Zl},walletData:Bl},Gr=e=>{const{variables:t,entityOwnership:n}=e,r=t===void 0?[]:Object.entries(t).filter(g=>g[1].type==="Key").map(([g])=>g),i=n===void 0?[]:Object.keys(Object.values(n).reduce((g,y)=>({...g,[y]:!0}),{})),o=[...r,...i].sort((g,y)=>g.localeCompare(y,"en")).reduce((g,y,v)=>({...g,[y]:cs(BigInt(v+1))}),{}),a=t===void 0?void 0:Object.entries(t).reduce((g,[y,v])=>v.type==="Key"?{...g,[y]:P(o[y])}:g,{}),s={data:{currentBlockHeight:z.defaultScenarioCurrentBlockHeight,currentBlockTime:z.defaultScenarioCurrentBlockTime,...a===void 0||Object.keys(a).length===0?{}:{keys:{privateKeys:a}}},sourceOutputs:[{lockingBytecode:["slot"]}],transaction:{inputs:[{unlockingBytecode:["slot"]}],locktime:z.defaultScenarioTransactionLocktime,outputs:[{lockingBytecode:z.defaultScenarioOutputLockingBytecode}],version:z.defaultScenarioTransactionVersion}};if(!(t===void 0?!1:Object.values(t).findIndex(g=>g.type==="HdKey")!==-1))return s;const{sha256:u,sha512:d}=e;if(u===void 0)return'An implementations of "sha256" is required to generate defaults for HD keys, but the "sha256" property is not included in this compiler configuration.';if(d===void 0)return'An implementations of "sha512" is required to generate defaults for HD keys, but the "sha512" property is not included in this compiler configuration.';const p={sha256:u,sha512:d},h=i.reduce((g,y)=>{const C=Qu(o[y],{assumeValidity:!0,crypto:p}),{hdPrivateKey:T}=al({network:"mainnet",node:C},{crypto:p});return{...g,[y]:T}},{});return{...s,data:{...s.data,hdKeys:{addressIndex:z.defaultScenarioAddressIndex,hdPrivateKeys:h}}}},Ro=(e,t)=>({...e,...t,...e.bytecode===void 0&&t.bytecode===void 0?{}:{bytecode:{...e.bytecode,...t.bytecode}},...e.hdKeys===void 0&&t.hdKeys===void 0?{}:{hdKeys:{...e.hdKeys,...t.hdKeys,...e.hdKeys?.hdPrivateKeys===void 0&&t.hdKeys?.hdPrivateKeys===void 0?{}:{hdPrivateKeys:{...e.hdKeys?.hdPrivateKeys,...t.hdKeys?.hdPrivateKeys}},...e.hdKeys?.hdPublicKeys===void 0&&t.hdKeys?.hdPublicKeys===void 0?{}:{hdPublicKeys:{...e.hdKeys?.hdPublicKeys,...t.hdKeys?.hdPublicKeys}}}},...e.keys===void 0&&t.keys===void 0?{}:{keys:{privateKeys:{...e.keys?.privateKeys,...t.keys?.privateKeys}}}}),zo=(e,t)=>({...e.data===void 0&&t.data===void 0?{}:{data:Ro(e.data??{},t.data??{})},...e.transaction===void 0&&t.transaction===void 0?{}:{transaction:{...e.transaction,...t.transaction}},...e.sourceOutputs===void 0&&t.sourceOutputs===void 0?{}:{sourceOutputs:t.sourceOutputs??e.sourceOutputs}}),Fo=({configuration:e,scenarioId:t,sourceScenarioIds:n=[]})=>{if(t===void 0)return Gr(e);if(n.includes(t))return`Cannot extend scenario "${t}": scenario "${t}" extends itself. Scenario inheritance path: ${n.join("  ")}`;const r=e.scenarios?.[t];if(r===void 0)return`Cannot extend scenario "${t}": a scenario with the identifier ${t} is not included in this compiler configuration.`;const i=r.extends===void 0?Gr(e):Fo({configuration:e,scenarioId:r.extends,sourceScenarioIds:[...n,t]});return typeof i=="string"?i:zo(i,r)},Vo=e=>({...e.data.currentBlockHeight===void 0?{}:{currentBlockHeight:e.data.currentBlockHeight},...e.data.currentBlockTime===void 0?{}:{currentBlockTime:e.data.currentBlockTime},...e.data.hdKeys===void 0?{}:{hdKeys:{...e.data.hdKeys.addressIndex===void 0?{}:{addressIndex:e.data.hdKeys.addressIndex},...e.data.hdKeys.hdPrivateKeys!==void 0&&Object.keys(e.data.hdKeys.hdPrivateKeys).length>0?{hdPrivateKeys:e.data.hdKeys.hdPrivateKeys}:{},...e.data.hdKeys.hdPublicKeys===void 0?{}:{hdPublicKeys:e.data.hdKeys.hdPublicKeys}}},...e.data.keys?.privateKeys!==void 0&&Object.keys(e.data.keys.privateKeys).length>0?{keys:{privateKeys:Object.entries(e.data.keys.privateKeys).reduce((t,[n,r])=>({...t,[n]:oe(r)}),{})}}:{}}),qo=({compilationData:e,configuration:t,scenarioDataBytecodeScripts:n})=>{const r=u=>`${z.scenarioBytecodeScriptPrefix}${u}`,i=Object.entries(n).reduce((u,[d,p])=>({...u,[r(d)]:p}),{}),o={...t,scripts:{...t.scripts,...i}},a=Object.keys(n).map(u=>{const d=nt({configuration:o,data:e,scriptId:r(u)});return d.success?{bytecode:d.bytecode,id:u}:{errors:d.errors,id:u}}),s=a.filter(u=>"errors"in u);if(s.length>0)return s.map(u=>`Compilation error while generating bytecode for "${u.id}": ${Eo(u.errors)}`).join("; ");const l=a.reduce((u,d)=>({...u,[d.id]:d.bytecode}),{});return{...Object.keys(l).length>0?{bytecode:l}:{},...e}},Wr=(e=z.defaultScenarioOutputValueSatoshis)=>typeof e=="string"?ss(oe(e)):BigInt(e),An=({bytecodeDefinition:e,compilationContext:t,configuration:n,defaultOverride:r,extendedScenario:i,generateBytecode:o,lockingOrUnlockingScriptIdUnderTest:a})=>{if(typeof e=="string")return oe(e);const s=e.script===void 0||Array.isArray(e.script)?a:e.script;if(s===void 0)return oe("");const l=e.overrides??r,u=Ro(i.data,l),d=qo({compilationData:Vo({data:u}),configuration:n,scenarioDataBytecodeScripts:u.bytecode??{}});return typeof d=="string"?{errors:[{error:`Could not compile scenario "data.bytecode": ${d}`}],success:!1}:o({data:{...d,compilationContext:t},debug:!0,scriptId:s})},Xr=e=>e.token===void 0?{}:{token:{amount:BigInt(e.token.amount??0),category:oe(e.token.category??z.defaultScenarioOutputTokenCategory),...e.token.nft===void 0?{}:{nft:{capability:e.token.nft.capability??"none",commitment:oe(e.token.nft.commitment??"")}}}},Wl=({configuration:e,generateBytecode:t,scenarioId:n,unlockingScriptId:r,lockingScriptId:i},o)=>{const{scenarioDefinition:a,scenarioName:s}=n===void 0?{scenarioDefinition:{},scenarioName:"the default scenario"}:{scenarioDefinition:e.scenarios?.[n],scenarioName:`scenario "${n}"`};if(a===void 0)return`Cannot generate ${s}: a scenario definition with the identifier ${n} is not included in this compiler configuration.`;const l=Fo({configuration:e,scenarioId:n});if(typeof l=="string")return`Cannot generate ${s}: ${l}`;const u=zo(l,a),d=Vo(u),p=qo({compilationData:d,configuration:e,scenarioDataBytecodeScripts:u.data.bytecode??{}});if(typeof p=="string")return`Cannot generate ${s}. ${p}`;if(u.transaction.inputs.length!==u.sourceOutputs.length)return`Cannot generate ${s}: could not match source outputs with inputs - "sourceOutputs" must be the same length as "transaction.inputs".`;if(u.transaction.inputs.filter(E=>Array.isArray(E.unlockingBytecode)).length!==1)return`Cannot generate ${s}: the specific input under test in this scenario is ambiguous - "transaction.inputs" must include exactly one input that has "unlockingBytecode" set to ["slot"].`;const g=u.transaction.inputs.findIndex(E=>Array.isArray(E.unlockingBytecode));if(u.sourceOutputs.filter(E=>Array.isArray(E.lockingBytecode)).length!==1)return`Cannot generate ${s}: the source output unlocked by the input under test in this scenario is ambiguous - "sourceOutputs" must include exactly one output that has "lockingBytecode" set to ["slot"].`;if(!Array.isArray(u.sourceOutputs[g]?.lockingBytecode))return`Cannot generate ${s}: the source output unlocked by the input under test in this scenario is ambiguous - the ["slot"] in "transaction.inputs" and "sourceOutputs" must be at the same index.`;if(r!==void 0&&i!==void 0)return`Cannot generate ${s}: a scenario cannot be generated with both unlocking and locking script IDs defined. If an unlocking script is provided, the associated locking script ID must be read from the template.`;const v=i??(r===void 0?void 0:e.unlockingScripts?.[r]);if(r!==void 0&&v===void 0)return`Cannot generate ${s} using unlocking script "${r}": the locking script unlocked by "${r}" is not provided in this compiler configuration.`;const C=u.sourceOutputs.map((E,L)=>{const X=Array.isArray(E.lockingBytecode),we=X?v===void 0?z.defaultScenarioBytecode:{script:v}:E.lockingBytecode??{};return{compiled:{lockingBytecode:An({bytecodeDefinition:we,configuration:e,defaultOverride:{},extendedScenario:u,generateBytecode:t,lockingOrUnlockingScriptIdUnderTest:v}),valueSatoshis:Wr(E.valueSatoshis),...Xr(E)},index:L,slot:X,type:"source output"}}),T=C.find(E=>E.slot)?.compiled.lockingBytecode,k=u.transaction.outputs.map((E,L)=>{const X={hdKeys:{addressIndex:1}};return{compiled:{lockingBytecode:An({bytecodeDefinition:E.lockingBytecode??{},configuration:e,defaultOverride:X,extendedScenario:u,generateBytecode:t,lockingOrUnlockingScriptIdUnderTest:v}),valueSatoshis:Wr(E.valueSatoshis),...Xr(E)},index:L,type:"transaction output"}}),O=[...C,...k].reduce((E,L)=>"errors"in L.compiled.lockingBytecode?[...E,...L.compiled.lockingBytecode.errors.map(X=>`Failed compilation of ${L.type} at index ${L.index}: ${X.error}`)]:E,[]);if(O.length>0){const E=`Cannot generate ${s}: ${O.join(" ")}`;return o===!0?{lockingCompilation:T,scenario:E}:E}const S=C,M=k,b=E=>{const{lockingBytecode:L,valueSatoshis:X,token:we}=E.compiled;return{lockingBytecode:"bytecode"in L?L.bytecode:L,valueSatoshis:X,...we===void 0?{}:{token:we}}},w=S.map(b),R=M.map(b),V=u.transaction.inputs.map((E,L)=>({outpointIndex:E.outpointIndex??L,outpointTransactionHash:oe(E.outpointTransactionHash??z.defaultScenarioInputOutpointTransactionHash),sequenceNumber:E.sequenceNumber??z.defaultScenarioInputSequenceNumber,unlockingBytecode:void 0})),ke=u.transaction.inputs.map((E,L)=>{const X=Array.isArray(E.unlockingBytecode),we=Array.isArray(E.unlockingBytecode)?r===void 0?z.defaultScenarioBytecode:{script:r}:E.unlockingBytecode??{},Qe={};return{compiled:{outpointIndex:V[L].outpointIndex,outpointTransactionHash:V[L].outpointTransactionHash,sequenceNumber:V[L].sequenceNumber,unlockingBytecode:An({bytecodeDefinition:we,compilationContext:{inputIndex:L,sourceOutputs:w,transaction:{inputs:V,locktime:u.transaction.locktime,outputs:R,version:u.transaction.version}},configuration:e,defaultOverride:Qe,extendedScenario:u,generateBytecode:t,lockingOrUnlockingScriptIdUnderTest:r})},index:L,slot:X}}),Se=ke.find(E=>E.slot)?.compiled.unlockingBytecode,ve=ke.reduce((E,L)=>"errors"in L.compiled.unlockingBytecode?[...E,...L.compiled.unlockingBytecode.errors.map(X=>`Failed compilation of input at index ${L.index}: ${X.error}`)]:E,[]);if(ve.length>0){const E=`Cannot generate ${s}: ${ve.join(" ")}`;return o===!0?{lockingCompilation:T,scenario:E,unlockingCompilation:Se}:E}const Re=ke.map(E=>{const{outpointIndex:L,outpointTransactionHash:X,sequenceNumber:we,unlockingBytecode:Qe}=E.compiled;return{outpointIndex:L,outpointTransactionHash:X,sequenceNumber:we,unlockingBytecode:"bytecode"in Qe?Qe.bytecode:Qe}}),wn={data:p,program:{inputIndex:g,sourceOutputs:w,transaction:{inputs:Re,locktime:u.transaction.locktime,outputs:R,version:u.transaction.version}}};return o===!0?{lockingCompilation:T,scenario:wn,unlockingCompilation:Se}:wn},Xl=e=>({data:t,debug:n,scriptId:r})=>{const i=Cl(r,t,e);return n===!0?i:i.success?{bytecode:i.bytecode,success:!0}:{errorType:i.errorType,errors:i.errors,success:!1}},Ql=e=>{const t=Xl(e);return{configuration:e,generateBytecode:t,generateScenario:({lockingScriptId:n,unlockingScriptId:r,scenarioId:i,debug:o})=>Wl({configuration:e,generateBytecode:t,lockingScriptId:n,scenarioId:i,unlockingScriptId:r},o)}},Jl=32,ed=e=>({inputIndex:0,sourceOutputs:[{lockingBytecode:e,valueSatoshis:0n}],transaction:{inputs:[{outpointIndex:0,outpointTransactionHash:new Uint8Array(Jl),sequenceNumber:0,unlockingBytecode:Uint8Array.of()}],locktime:0,outputs:[{lockingBytecode:Ee([Uint8Array.of(Wu.OP_RETURN)]),valueSatoshis:0n}],version:0}});Pr();const td=e=>{const t=Object.entries(e.scripts).reduce((d,[p,h])=>"tests"in h?{...d,...Object.entries(h.tests).reduce((g,[y,v])=>{const C=h.pushed===!0,T=`${p}.${y}.check`,k=`${p}.${y}.lock`,O=`${p}.${y}.unlock`;return{...g,[T]:{script:v.check},[k]:{lockingType:"p2sh20",script:C?`<${p}> ${T}`:`${p} ${T}`},[O]:{script:v.setup??"",unlocks:k}}},{})}:d,{}),n={...e.scripts,...t},r=Object.entries(n).reduce((d,[p,h])=>({...d,[p]:h.script}),{}),i=Object.values(e.entities).reduce((d,p)=>({...d,...p.variables}),{}),o=Object.entries(e.entities).reduce((d,[p,h])=>({...d,...Object.keys(h.variables??{}).reduce((g,y)=>({...g,[y]:p}),{})}),{}),a=Object.entries(n).reduce((d,[p,h])=>"unlocks"in h&&h.unlocks!==void 0?{...d,[p]:h.unlocks}:d,{}),s=Object.entries(n).reduce((d,[p,h])=>"timeLockType"in h&&h.timeLockType!==void 0?{...d,[p]:h.timeLockType}:d,{}),l=Object.entries(n).reduce((d,[p,h])=>"lockingType"in h&&h.lockingType!==void 0?{...d,[p]:h.lockingType}:d,{}),u=e.scenarios===void 0?void 0:Object.entries(e.scenarios).reduce((d,[p,h])=>({...d,[p]:h}),{});return{entityOwnership:o,lockingScriptTypes:l,...u===void 0?{}:{scenarios:u},scripts:r,unlockingScriptTimeLockTypes:s,unlockingScripts:a,variables:i}};var j;(function(e){e.allOutputs="all_outputs",e.allOutputsAllUtxos="all_outputs_all_utxos",e.allOutputsSingleInput="all_outputs_single_input",e.allOutputsSingleInputInvalidAllUtxos="all_outputs_single_input_INVALID_all_utxos",e.correspondingOutput="corresponding_output",e.correspondingOutputAllUtxos="corresponding_output_all_utxos",e.correspondingOutputSingleInput="corresponding_output_single_input",e.correspondingOutputSingleInputInvalidAllUtxos="corresponding_output_single_input_INVALID_all_utxos",e.default="default",e.noOutputs="no_outputs",e.noOutputsAllUtxos="no_outputs_all_utxos",e.noOutputsSingleInput="no_outputs_single_input",e.noOutputsSingleInputInvalidAllUtxos="no_outputs_single_input_INVALID_all_utxos"})(j||(j={}));const Yo=(e,t="")=>{switch(e){case`${t}${j.allOutputs}`:return Uint8Array.of(Oe.allOutputs);case`${t}${j.allOutputsAllUtxos}`:case`${t}${j.default}`:return Uint8Array.of(Oe.allOutputsAllUtxos);case`${t}${j.allOutputsSingleInput}`:return Uint8Array.of(Oe.allOutputsSingleInput);case`${t}${j.allOutputsSingleInputInvalidAllUtxos}`:return Uint8Array.of(se.allOutputs|se.singleInput|se.utxos|se.forkId);case`${t}${j.correspondingOutput}`:return Uint8Array.of(Oe.correspondingOutput);case`${t}${j.correspondingOutputAllUtxos}`:return Uint8Array.of(Oe.correspondingOutputAllUtxos);case`${t}${j.correspondingOutputSingleInput}`:return Uint8Array.of(Oe.correspondingOutputSingleInput);case`${t}${j.correspondingOutputSingleInputInvalidAllUtxos}`:return Uint8Array.of(se.correspondingOutput|se.singleInput|se.utxos|se.forkId);case`${t}${j.noOutputs}`:return Uint8Array.of(Oe.noOutputs);case`${t}${j.noOutputsAllUtxos}`:return Uint8Array.of(Oe.noOutputsAllUtxos);case`${t}${j.noOutputsSingleInput}`:return Uint8Array.of(Oe.noOutputsSingleInput);case`${t}${j.noOutputsSingleInputInvalidAllUtxos}`:return Uint8Array.of(se.noOutputs|se.singleInput|se.utxos|se.forkId);default:return}},Zo=({coveredBytecode:e,identifier:t,compilationContext:n,operationName:r,privateKey:i,sha256:o,sign:a})=>{const[,,s,l]=t.split(".");if(l!==void 0)return{error:`Unknown component in "${t}" - the fragment "${l}" is not recognized.`,status:"error"};if(s===void 0)return{error:`Invalid signature identifier. Signatures must be of the form: "[variable_id].${r}.[signing_serialization_type]".`,status:"error"};const u=Yo(s);if(u===void 0)return{error:`Unknown signing serialization algorithm, "${s}".`,status:"error"};const d=Et(n,{coveredBytecode:e,signingSerializationType:u},o),p=Bt(d,o);return{bytecode:Uint8Array.from([...a(i,p),...u]),signature:{serialization:d},status:"success"}},jo=({operationName:e,secp256k1Method:t})=>ht([mt],H({canBeSkipped:!1,configurationProperties:["entityOwnership","ripemd160","secp256k1","sha256","sha512","variables","sourceScriptIds","unlockingScripts"],dataProperties:["hdKeys","compilationContext"],operation:(n,r,i)=>{const{hdKeys:o,compilationContext:a}=r,{secp256k1:s,sha256:l,sourceScriptIds:u,unlockingScripts:d}=i,p=Do({configuration:i,hdKeys:o,identifier:n});if(p.status==="error")return p;const h=Tn({configuration:i,data:r,identifier:n,sourceScriptIds:u,unlockingScripts:d});return"error"in h?h:Zo({compilationContext:a,coveredBytecode:h,identifier:n,operationName:e,privateKey:p.bytecode,sha256:l,sign:s[t]})}})),nd=jo({operationName:"ecdsa_signature",secp256k1Method:"signMessageHashDER"}),rd=jo({operationName:"schnorr_signature",secp256k1Method:"signMessageHashSchnorr"}),Go=({operationName:e,secp256k1Method:t})=>ht([mt],H({canBeSkipped:!1,configurationProperties:["sha256","secp256k1","unlockingScripts","sourceScriptIds"],dataProperties:["keys","compilationContext"],operation:(n,r,i)=>{const{keys:o,compilationContext:a}=r,{secp256k1:s,sha256:l,unlockingScripts:u,sourceScriptIds:d}=i,{privateKeys:p}=o,[h]=n.split("."),g=p===void 0?void 0:p[h];if(g===void 0)return{error:`Identifier "${n}" refers to a Key, but a private key for "${h}" (or an existing signature) was not provided in the compilation data.`,recoverable:!0,status:"error"};const y=Tn({configuration:i,data:r,identifier:n,sourceScriptIds:d,unlockingScripts:u});return"error"in y?y:Zo({compilationContext:a,coveredBytecode:y,identifier:n,operationName:e,privateKey:g,sha256:l,sign:s[t]})}})),id=Go({operationName:"ecdsa_signature",secp256k1Method:"signMessageHashDER"}),od=Go({operationName:"schnorr_signature",secp256k1Method:"signMessageHashSchnorr"}),Wo=({data:e,configuration:t,identifier:n,operationName:r,privateKey:i,sha256:o,sign:a})=>{const[,,s,l]=n.split(".");if(l!==void 0)return{error:`Unknown component in "${n}" - the fragment "${l}" is not recognized.`,status:"error"};if(s===void 0)return{error:`Invalid data signature identifier. Data signatures must be of the form: "[variable_id].${r}.[target_script_id]".`,status:"error"};const u=Ko({configuration:t,data:e,targetScriptId:s});if(u===!1)return{error:`Data signature tried to sign an unknown target script, "${s}".`,status:"error"};if("error"in u)return u;const d=o.hash(u);return{bytecode:a(i,d),signature:{digest:d,message:u},status:"success"}},Xo=({operationName:e,secp256k1Method:t})=>ht([mt],H({canBeSkipped:!1,configurationProperties:["sha256","secp256k1"],dataProperties:["keys"],operation:(n,r,i)=>{const{keys:o}=r,{secp256k1:a,sha256:s}=i,{privateKeys:l}=o,[u]=n.split("."),d=l===void 0?void 0:l[u];return d===void 0?{error:`Identifier "${n}" refers to a Key, but a private key for "${u}" (or an existing signature) was not provided in the compilation data.`,recoverable:!0,status:"error"}:Wo({configuration:i,data:r,identifier:n,operationName:e,privateKey:d,sha256:s,sign:a[t]})}})),ad=Xo({operationName:"ecdsa_data_signature",secp256k1Method:"signMessageHashDER"}),sd=Xo({operationName:"schnorr_data_signature",secp256k1Method:"signMessageHashSchnorr"}),Qo=({operationName:e,secp256k1Method:t})=>ht([mt],H({canBeSkipped:!1,configurationProperties:["entityOwnership","ripemd160","secp256k1","sha256","sha512","variables"],dataProperties:["hdKeys"],operation:(n,r,i)=>{const{hdKeys:o}=r,{secp256k1:a,sha256:s}=i,l=Do({configuration:i,hdKeys:o,identifier:n});return l.status==="error"?l:Wo({configuration:i,data:r,identifier:n,operationName:e,privateKey:l.bytecode,sha256:s,sign:a[t]})}})),cd=Qo({operationName:"ecdsa_data_signature",secp256k1Method:"signMessageHashDER"}),ud=Qo({operationName:"schnorr_data_signature",secp256k1Method:"signMessageHashSchnorr"}),ld=H({canBeSkipped:!1,configurationProperties:[],dataProperties:["compilationContext"],operation:(e,t)=>({bytecode:ls(t.compilationContext.sourceOutputs[t.compilationContext.inputIndex].token),status:"success"})}),Qr=e=>({error:`The "signature" compiler operation was renamed to "ecdsa_signature". Consider fixing this error by changing "${e}" to "${e.replace("signature","schnorr_signature")}" (schnorr signatures reduce transaction sizes and enable multi-party signature aggregation).`,status:"error"}),Jr=e=>({error:`The "data_signature" compiler operation was renamed to "ecdsa_data_signature". Consider fixing this error by changing "${e}" to "${e.replace("data_signature","schnorr_data_signature")}" (schnorr signatures reduce transaction sizes and enable multi-party signature aggregation).`,status:"error"}),te=H({canBeSkipped:!1,configurationProperties:["sha256","sourceScriptIds","unlockingScripts"],dataProperties:["compilationContext"],operation:(e,t,n)=>{const[,r,i]=e.split(".");if(r===void 0)return{error:'Invalid signing serialization operation. Include the desired component or algorithm, e.g. "signing_serialization.version".',status:"error"};if(i!==void 0)return{error:`Unknown component in "${e}" - the fragment "${i}" is not recognized.`,status:"error"};const o=Yo(r,"full_");if(o===void 0)return{error:`Unknown signing serialization algorithm, "${r}".`,status:"error"};const{sha256:a,sourceScriptIds:s,unlockingScripts:l}=n,u=Tn({configuration:n,data:t,identifier:e,sourceScriptIds:s,unlockingScripts:l});if("error"in u)return u;const{compilationContext:d}=t;return{bytecode:Et(d,{coveredBytecode:u,signingSerializationType:o},a),status:"success"}}}),dd={...tn,hdKey:{data_signature:Jr,ecdsa_data_signature:cd,ecdsa_signature:nd,public_key:tn.hdKey.public_key,schnorr_data_signature:ud,schnorr_signature:rd,signature:Qr},key:{data_signature:Jr,ecdsa_data_signature:ad,ecdsa_signature:id,public_key:tn.key.public_key,schnorr_data_signature:sd,schnorr_signature:od,signature:Qr},signingSerialization:{...tn.signingSerialization,full_all_outputs:te,full_all_outputs_all_utxos:te,full_all_outputs_single_input:te,full_all_outputs_single_input_INVALID_all_utxos:te,full_corresponding_output:te,full_corresponding_output_all_utxos:te,full_corresponding_output_single_input:te,full_corresponding_output_single_input_INVALID_all_utxos:te,full_default:te,full_no_outputs:te,full_no_outputs_all_utxos:te,full_no_outputs_single_input:te,full_no_outputs_single_input_INVALID_all_utxos:te,token_prefix:ld}},pd=e=>Ql({createAuthenticationProgram:ed,opcodes:us(It),operations:dd,ripemd160:ae,secp256k1:F,sha256:K,sha512:Ge,vm:e.vm??Pr(),...e}),hd=pd;function md(e,t){if(t==="ts"){const n=JSON.parse(JSON.stringify(e));return`export default ${Jn(n)} as const;
`}return JSON.stringify(e,null,2)}const nn=e=>"  ".repeat(e);function Jn(e,t=1){if(typeof e=="string")return`'${JSON.stringify(e).replace(/'/g,"\\'").replace(/\\"/g,'"').slice(1,-1)}'`;if(typeof e=="number"||typeof e=="boolean")return JSON.stringify(e);if(Array.isArray(e))return e.length===0?"[]":`[
${e.map(r=>`${nn(t)}${Jn(r,t+1)}`).join(`,
`)},
${nn(t-1)}]`;if(typeof e=="object"){const n=Object.entries(e);return n.length===0?"{}":`{
${n.map(([i,o])=>`${nn(t)}${i}: ${Jn(o,t+1)}`).join(`,
`)},
${nn(t-1)}}`}throw new Error(`Unsupported type: ${typeof e}`)}const fd=4294967295,gd=1<<31,Cn=9,wt=65535,Jo=1<<22,_d=wt,ei=1<<Cn,ti=wt<<Cn;function yd(e){return e&gd?{}:e&Jo?{seconds:(e&wt)<<Cn}:{blocks:e&wt}}function bd({blocks:e,seconds:t}){if(e!==void 0&&t!==void 0)throw new TypeError("Cannot encode blocks AND seconds");if(t!==void 0){if(!Number.isFinite(t))throw new TypeError("Expected Number seconds");if(t>ti)throw new TypeError("Expected Number seconds <= "+ti);if(t%ei!==0)throw new TypeError("Expected Number seconds as a multiple of "+ei);return Jo|t>>Cn}if(e!==void 0){if(!Number.isFinite(e))throw new TypeError("Expected Number blocks");if(e>wt)throw new TypeError("Expected Number blocks <= "+_d);return e}return fd}function ea(e,t){return Oi(t).reduce((r,{location:i,positionHint:o},a)=>{const s=e[a],l=o===xi.END?i?.end.line:i?.start.line;return{...r,[l]:[...r[l]||[],s]}},{})}function ta(e,t){const n=ea(e,t);return Object.fromEntries(Object.entries(n).map(([r,i])=>[r,vi(i)]))}function na(e,t,n){const r=ta(e,t),o=n.replaceAll("/*","\\/*").replaceAll("*/","*\\/").split(`
`),a=o.map(p=>p.length),s=Object.values(r).map(p=>p.length),l=Math.max(...a),u=Math.max(...s);return o.map((p,h)=>`${(r[h+1]||"").padEnd(u)} /* ${p.padEnd(l)} */`).join(`
`)}const Wh=Object.freeze(Object.defineProperty({__proto__:null,ArrayType:ds,BytesType:ps,Op:Ce,get PositionHint(){return xi},get PrimitiveType(){return on},TupleType:hs,arrayType:ms,asmToBytecode:Pi,asmToScript:fs,bitAuthAsmToScript:gs,buildLineToAsmMap:ta,buildLineToOpcodesMap:ea,bytecodeToAsm:_s,bytecodeToBitAuthAsm:ys,bytecodeToScript:Ti,calculateBytesize:bs,countOpcodes:ks,decodeBip68:yd,decodeBool:Ci,decodeInt:Ei,decodeString:Bi,encodeBip68:bd,encodeBool:Ss,encodeInt:vs,encodeNullDataScript:Os,encodeString:xs,explicitlyCastable:Ps,formatArtifact:md,formatBitAuthScript:na,generateRedeemScript:Ts,generateSourceMap:Cs,hash160:Es,hash256:Bs,implicitlyCastable:Is,implicitlyCastableSignature:ws,isPrimitive:$s,optimiseBytecode:As,optimiseBytecodeOld:Ns,parseType:Hs,placeholder:Ls,resultingType:Us,ripemd160:Ds,scriptToAsm:Ks,scriptToBitAuthAsm:vi,scriptToBytecode:Ii,sha256:Rn,sha512:Ms,sourceMapToLocationData:Oi},Symbol.toStringTag,{value:"Module"})),kd=e=>{switch(e){case"BCH_2023_05":return Cu();case"BCH_2025_05":return ju();case"BCH_2026_05":return Gu();case"BCH_SPEC":return Pr();default:throw new Error(`Debugging is not supported for the ${e} virtual machine.`)}},Sd=(e,t)=>{if(t.some(o=>t.some(a=>a.contractName===o.contractName&&a.bytecode!==o.bytecode)))throw new Error("There are multiple artifacts with the same contractName. Please make sure that all artifacts have unique names.");const r={},i=Object.keys(e.scripts).filter(o=>"unlocks"in e.scripts[o]);for(const o of i){const a=e.scripts[o].passes??[],s=t.find(l=>o.startsWith(l.contractName));for(const l of a)r[`${o}.${l}`]=vd(e,s,o,l)}return Id(e),r},vd=(e,t,n,r)=>{const{vm:i,program:o}=ra(e,n,r),a=i.debug(o),l=a.slice(Rs(a,p=>p.ip===0)).filter(p=>p.controlStack.every(h=>h===!0));if(t){const p=(t.debug?.logs??[]).filter(h=>l.some(g=>h.ip===g.ip));for(const h of p){const g=Od(r);xd(h,l,t,g,i)}}const u=l[l.length-1];if(u.error){const p=u.ip-1,h=u.instructions[p],g=u.error.includes(f.nonNullSignatureFailure),y=p+(g&&wd(h)?1:0),{program:{inputIndex:v},error:C}=u;if(!t)throw new it(C,pe(e));const T=(t.debug?.requires??[]).find(k=>k.ip===y);throw T?new Dr(t,p,T,v,pe(e),C):new Kr(t,p,v,pe(e),C)}const d=i.stateSuccess(u);if(Cd(d)){const p=Bd(l),h=p-1,{program:{inputIndex:g}}=u;if(!t)throw new it(d,pe(e));const y=(t.debug?.requires??[]).find(v=>v.ip===p);throw y?new Dr(t,h,y,g,pe(e)):new Kr(t,h,g,pe(e),d)}return a},Od=e=>{const t=e.match(/_input(\d+)_/);if(!t)throw new Error(`Invalid scenario ID: ${e}`);return parseInt(t[1])},ra=(e,t,n)=>{const r=td(e),i=kd(e.supported[0]),o=hd(r);if(!e.scripts[t])throw new Error(`No unlock script found in template for ID ${t}`);if(!e.scenarios?.[n])throw new Error(`No scenario found in template for ID ${n}`);const a=o.generateScenario({debug:!0,unlockingScriptId:t,scenarioId:n});if(typeof a=="string")throw new it(a,pe(e));if(typeof a.scenario=="string")throw new it(a.scenario,pe(e));return{vm:i,program:a.scenario.program}},xd=(e,t,n,r,i)=>{let o=`${n.contractName}.cash:${e.line}`;const a=e.data.map(s=>{if(typeof s=="string")return s;const l=t.find(d=>d.ip===s.ip),u=Pd(s,l,i);return Td(s,u.stack)});console.log(`[Input #${r}] ${o} ${a.join(" ")}`)},Pd=(e,t,n)=>{if(!e.transformations)return t;const r=Pi(e.transformations),i=qe(r),o={alternateStack:[...t.alternateStack],controlStack:[],ip:0,lastCodeSeparator:-1,metrics:{},stack:[...t.stack],operationCount:0,instructions:i,signedMessages:[],program:{...t.program},functionTable:t.functionTable??{},functionCount:t.functionCount??0};return n.stateEvaluate(o)},Td=(e,t)=>{const n=[...t].reverse()[e.stackIndex];if(!n)throw Error(`Stack item at index ${e.stackIndex} not found at instruction pointer ${e.ip}`);return e.type===on.BOOL?Ci(n):e.type===on.INT?Ei(n):e.type===on.STRING?Bi(n):`0x${P(n)}`},Cd=e=>e===!0?!1:zs(["The CashAssembly internal evaluation completed with an unexpected number of items on the stack (must be exactly 1).","The CashAssembly internal evaluation completed with a non-empty control stack.",f.unsuccessfulEvaluation]).test(e),Ed=e=>{const t=[Ce.OP_ENDIF,Ce.OP_NIP,Ce.OP_ELSE,Ce.OP_DROP,Ce.OP_2DROP];let n=0;for(const r of[...e].reverse())if(!r||t.includes(r.opcode))n++;else break;return n},Bd=e=>{const t=e.map(a=>a.instructions[a.ip]),n=e.length-1,r=Ed(t);return e[n-r].ip+1},Id=e=>{const t=Object.keys(e.scripts).find(a=>"unlocks"in e.scripts[a]),n=e.scripts[t??""]?.passes?.[0];if(!n||!t)throw new Error("No placeholder scenario ID or script ID found");const{vm:r,program:i}=ra(e,t,n),o=r.verify({sourceOutputs:i.sourceOutputs,transaction:i.transaction});if(typeof o=="string")throw new it(o,pe(e))},wd=e=>[Ce.OP_CHECKSIG,Ce.OP_CHECKMULTISIG,Ce.OP_CHECKDATASIG].includes(e.opcode);/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */const $d=4,ni=0,ri=1,Ad=2;function ft(e){let t=e.length;for(;--t>=0;)e[t]=0}const Nd=0,ia=1,Hd=2,Ld=3,Ud=258,wr=29,Zt=256,$t=Zt+1+wr,rt=30,$r=19,oa=2*$t+1,ze=15,Nn=16,Dd=7,Ar=256,aa=16,sa=17,ca=18,er=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),an=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),Kd=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),ua=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Md=512,Te=new Array(($t+2)*2);ft(Te);const Tt=new Array(rt*2);ft(Tt);const At=new Array(Md);ft(At);const Nt=new Array(Ud-Ld+1);ft(Nt);const Nr=new Array(wr);ft(Nr);const mn=new Array(rt);ft(mn);function Hn(e,t,n,r,i){this.static_tree=e,this.extra_bits=t,this.extra_base=n,this.elems=r,this.max_length=i,this.has_stree=e&&e.length}let la,da,pa;function Ln(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}const ha=e=>e<256?At[e]:At[256+(e>>>7)],Ht=(e,t)=>{e.pending_buf[e.pending++]=t&255,e.pending_buf[e.pending++]=t>>>8&255},Q=(e,t,n)=>{e.bi_valid>Nn-n?(e.bi_buf|=t<<e.bi_valid&65535,Ht(e,e.bi_buf),e.bi_buf=t>>Nn-e.bi_valid,e.bi_valid+=n-Nn):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=n)},me=(e,t,n)=>{Q(e,n[t*2],n[t*2+1])},ma=(e,t)=>{let n=0;do n|=e&1,e>>>=1,n<<=1;while(--t>0);return n>>>1},Rd=e=>{e.bi_valid===16?(Ht(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=e.bi_buf&255,e.bi_buf>>=8,e.bi_valid-=8)},zd=(e,t)=>{const n=t.dyn_tree,r=t.max_code,i=t.stat_desc.static_tree,o=t.stat_desc.has_stree,a=t.stat_desc.extra_bits,s=t.stat_desc.extra_base,l=t.stat_desc.max_length;let u,d,p,h,g,y,v=0;for(h=0;h<=ze;h++)e.bl_count[h]=0;for(n[e.heap[e.heap_max]*2+1]=0,u=e.heap_max+1;u<oa;u++)d=e.heap[u],h=n[n[d*2+1]*2+1]+1,h>l&&(h=l,v++),n[d*2+1]=h,!(d>r)&&(e.bl_count[h]++,g=0,d>=s&&(g=a[d-s]),y=n[d*2],e.opt_len+=y*(h+g),o&&(e.static_len+=y*(i[d*2+1]+g)));if(v!==0){do{for(h=l-1;e.bl_count[h]===0;)h--;e.bl_count[h]--,e.bl_count[h+1]+=2,e.bl_count[l]--,v-=2}while(v>0);for(h=l;h!==0;h--)for(d=e.bl_count[h];d!==0;)p=e.heap[--u],!(p>r)&&(n[p*2+1]!==h&&(e.opt_len+=(h-n[p*2+1])*n[p*2],n[p*2+1]=h),d--)}},fa=(e,t,n)=>{const r=new Array(ze+1);let i=0,o,a;for(o=1;o<=ze;o++)i=i+n[o-1]<<1,r[o]=i;for(a=0;a<=t;a++){let s=e[a*2+1];s!==0&&(e[a*2]=ma(r[s]++,s))}},Fd=()=>{let e,t,n,r,i;const o=new Array(ze+1);for(n=0,r=0;r<wr-1;r++)for(Nr[r]=n,e=0;e<1<<er[r];e++)Nt[n++]=r;for(Nt[n-1]=r,i=0,r=0;r<16;r++)for(mn[r]=i,e=0;e<1<<an[r];e++)At[i++]=r;for(i>>=7;r<rt;r++)for(mn[r]=i<<7,e=0;e<1<<an[r]-7;e++)At[256+i++]=r;for(t=0;t<=ze;t++)o[t]=0;for(e=0;e<=143;)Te[e*2+1]=8,e++,o[8]++;for(;e<=255;)Te[e*2+1]=9,e++,o[9]++;for(;e<=279;)Te[e*2+1]=7,e++,o[7]++;for(;e<=287;)Te[e*2+1]=8,e++,o[8]++;for(fa(Te,$t+1,o),e=0;e<rt;e++)Tt[e*2+1]=5,Tt[e*2]=ma(e,5);la=new Hn(Te,er,Zt+1,$t,ze),da=new Hn(Tt,an,0,rt,ze),pa=new Hn(new Array(0),Kd,0,$r,Dd)},ga=e=>{let t;for(t=0;t<$t;t++)e.dyn_ltree[t*2]=0;for(t=0;t<rt;t++)e.dyn_dtree[t*2]=0;for(t=0;t<$r;t++)e.bl_tree[t*2]=0;e.dyn_ltree[Ar*2]=1,e.opt_len=e.static_len=0,e.sym_next=e.matches=0},_a=e=>{e.bi_valid>8?Ht(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0},ii=(e,t,n,r)=>{const i=t*2,o=n*2;return e[i]<e[o]||e[i]===e[o]&&r[t]<=r[n]},Un=(e,t,n)=>{const r=e.heap[n];let i=n<<1;for(;i<=e.heap_len&&(i<e.heap_len&&ii(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!ii(t,r,e.heap[i],e.depth));)e.heap[n]=e.heap[i],n=i,i<<=1;e.heap[n]=r},oi=(e,t,n)=>{let r,i,o=0,a,s;if(e.sym_next!==0)do r=e.pending_buf[e.sym_buf+o++]&255,r+=(e.pending_buf[e.sym_buf+o++]&255)<<8,i=e.pending_buf[e.sym_buf+o++],r===0?me(e,i,t):(a=Nt[i],me(e,a+Zt+1,t),s=er[a],s!==0&&(i-=Nr[a],Q(e,i,s)),r--,a=ha(r),me(e,a,n),s=an[a],s!==0&&(r-=mn[a],Q(e,r,s)));while(o<e.sym_next);me(e,Ar,t)},tr=(e,t)=>{const n=t.dyn_tree,r=t.stat_desc.static_tree,i=t.stat_desc.has_stree,o=t.stat_desc.elems;let a,s,l=-1,u;for(e.heap_len=0,e.heap_max=oa,a=0;a<o;a++)n[a*2]!==0?(e.heap[++e.heap_len]=l=a,e.depth[a]=0):n[a*2+1]=0;for(;e.heap_len<2;)u=e.heap[++e.heap_len]=l<2?++l:0,n[u*2]=1,e.depth[u]=0,e.opt_len--,i&&(e.static_len-=r[u*2+1]);for(t.max_code=l,a=e.heap_len>>1;a>=1;a--)Un(e,n,a);u=o;do a=e.heap[1],e.heap[1]=e.heap[e.heap_len--],Un(e,n,1),s=e.heap[1],e.heap[--e.heap_max]=a,e.heap[--e.heap_max]=s,n[u*2]=n[a*2]+n[s*2],e.depth[u]=(e.depth[a]>=e.depth[s]?e.depth[a]:e.depth[s])+1,n[a*2+1]=n[s*2+1]=u,e.heap[1]=u++,Un(e,n,1);while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],zd(e,t),fa(n,l,e.bl_count)},ai=(e,t,n)=>{let r,i=-1,o,a=t[0*2+1],s=0,l=7,u=4;for(a===0&&(l=138,u=3),t[(n+1)*2+1]=65535,r=0;r<=n;r++)o=a,a=t[(r+1)*2+1],!(++s<l&&o===a)&&(s<u?e.bl_tree[o*2]+=s:o!==0?(o!==i&&e.bl_tree[o*2]++,e.bl_tree[aa*2]++):s<=10?e.bl_tree[sa*2]++:e.bl_tree[ca*2]++,s=0,i=o,a===0?(l=138,u=3):o===a?(l=6,u=3):(l=7,u=4))},si=(e,t,n)=>{let r,i=-1,o,a=t[0*2+1],s=0,l=7,u=4;for(a===0&&(l=138,u=3),r=0;r<=n;r++)if(o=a,a=t[(r+1)*2+1],!(++s<l&&o===a)){if(s<u)do me(e,o,e.bl_tree);while(--s!==0);else o!==0?(o!==i&&(me(e,o,e.bl_tree),s--),me(e,aa,e.bl_tree),Q(e,s-3,2)):s<=10?(me(e,sa,e.bl_tree),Q(e,s-3,3)):(me(e,ca,e.bl_tree),Q(e,s-11,7));s=0,i=o,a===0?(l=138,u=3):o===a?(l=6,u=3):(l=7,u=4)}},Vd=e=>{let t;for(ai(e,e.dyn_ltree,e.l_desc.max_code),ai(e,e.dyn_dtree,e.d_desc.max_code),tr(e,e.bl_desc),t=$r-1;t>=3&&e.bl_tree[ua[t]*2+1]===0;t--);return e.opt_len+=3*(t+1)+5+5+4,t},qd=(e,t,n,r)=>{let i;for(Q(e,t-257,5),Q(e,n-1,5),Q(e,r-4,4),i=0;i<r;i++)Q(e,e.bl_tree[ua[i]*2+1],3);si(e,e.dyn_ltree,t-1),si(e,e.dyn_dtree,n-1)},Yd=e=>{let t=4093624447,n;for(n=0;n<=31;n++,t>>>=1)if(t&1&&e.dyn_ltree[n*2]!==0)return ni;if(e.dyn_ltree[9*2]!==0||e.dyn_ltree[10*2]!==0||e.dyn_ltree[13*2]!==0)return ri;for(n=32;n<Zt;n++)if(e.dyn_ltree[n*2]!==0)return ri;return ni};let ci=!1;const Zd=e=>{ci||(Fd(),ci=!0),e.l_desc=new Ln(e.dyn_ltree,la),e.d_desc=new Ln(e.dyn_dtree,da),e.bl_desc=new Ln(e.bl_tree,pa),e.bi_buf=0,e.bi_valid=0,ga(e)},ya=(e,t,n,r)=>{Q(e,(Nd<<1)+(r?1:0),3),_a(e),Ht(e,n),Ht(e,~n),n&&e.pending_buf.set(e.window.subarray(t,t+n),e.pending),e.pending+=n},jd=e=>{Q(e,ia<<1,3),me(e,Ar,Te),Rd(e)},Gd=(e,t,n,r)=>{let i,o,a=0;e.level>0?(e.strm.data_type===Ad&&(e.strm.data_type=Yd(e)),tr(e,e.l_desc),tr(e,e.d_desc),a=Vd(e),i=e.opt_len+3+7>>>3,o=e.static_len+3+7>>>3,o<=i&&(i=o)):i=o=n+5,n+4<=i&&t!==-1?ya(e,t,n,r):e.strategy===$d||o===i?(Q(e,(ia<<1)+(r?1:0),3),oi(e,Te,Tt)):(Q(e,(Hd<<1)+(r?1:0),3),qd(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),oi(e,e.dyn_ltree,e.dyn_dtree)),ga(e),r&&_a(e)},Wd=(e,t,n)=>(e.pending_buf[e.sym_buf+e.sym_next++]=t,e.pending_buf[e.sym_buf+e.sym_next++]=t>>8,e.pending_buf[e.sym_buf+e.sym_next++]=n,t===0?e.dyn_ltree[n*2]++:(e.matches++,t--,e.dyn_ltree[(Nt[n]+Zt+1)*2]++,e.dyn_dtree[ha(t)*2]++),e.sym_next===e.sym_end);var Xd=Zd,Qd=ya,Jd=Gd,ep=Wd,tp=jd,np={_tr_init:Xd,_tr_stored_block:Qd,_tr_flush_block:Jd,_tr_tally:ep,_tr_align:tp};const rp=(e,t,n,r)=>{let i=e&65535|0,o=e>>>16&65535|0,a=0;for(;n!==0;){a=n>2e3?2e3:n,n-=a;do i=i+t[r++]|0,o=o+i|0;while(--a);i%=65521,o%=65521}return i|o<<16|0};var ba=rp;const ip=()=>{let e,t=[];for(var n=0;n<256;n++){e=n;for(var r=0;r<8;r++)e=e&1?3988292384^e>>>1:e>>>1;t[n]=e}return t},op=new Uint32Array(ip()),ap=(e,t,n,r)=>{const i=op,o=r+n;e^=-1;for(let a=r;a<o;a++)e=e>>>8^i[(e^t[a])&255];return e^-1};var Ae=ap,fn={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},ka={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_OK:0,Z_STREAM_END:1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:sp,_tr_stored_block:nr,_tr_flush_block:cp,_tr_tally:Ue,_tr_align:up}=np,{Z_NO_FLUSH:De,Z_PARTIAL_FLUSH:lp,Z_FULL_FLUSH:dp,Z_FINISH:ce,Z_BLOCK:ui,Z_OK:Y,Z_STREAM_END:li,Z_STREAM_ERROR:fe,Z_DATA_ERROR:pp,Z_BUF_ERROR:Dn,Z_DEFAULT_COMPRESSION:hp,Z_FILTERED:mp,Z_HUFFMAN_ONLY:rn,Z_RLE:fp,Z_FIXED:gp,Z_DEFAULT_STRATEGY:_p,Z_UNKNOWN:yp,Z_DEFLATED:En}=ka,bp=9,kp=15,Sp=8,vp=29,Op=256,rr=Op+1+vp,xp=30,Pp=19,Tp=2*rr+1,Cp=15,A=3,He=258,ge=He+A+1,Ep=32,st=42,Hr=57,ir=69,or=73,ar=91,sr=103,Fe=113,kt=666,G=1,gt=2,je=3,_t=4,Bp=3,Ve=(e,t)=>(e.msg=fn[t],t),di=e=>e*2-(e>4?9:0),Ne=e=>{let t=e.length;for(;--t>=0;)e[t]=0},Ip=e=>{let t,n,r,i=e.w_size;t=e.hash_size,r=t;do n=e.head[--r],e.head[r]=n>=i?n-i:0;while(--t);t=i,r=t;do n=e.prev[--r],e.prev[r]=n>=i?n-i:0;while(--t)};let wp=(e,t,n)=>(t<<e.hash_shift^n)&e.hash_mask,Ke=wp;const ne=e=>{const t=e.state;let n=t.pending;n>e.avail_out&&(n=e.avail_out),n!==0&&(e.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+n),e.next_out),e.next_out+=n,t.pending_out+=n,e.total_out+=n,e.avail_out-=n,t.pending-=n,t.pending===0&&(t.pending_out=0))},ie=(e,t)=>{cp(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,ne(e.strm)},N=(e,t)=>{e.pending_buf[e.pending++]=t},bt=(e,t)=>{e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=t&255},cr=(e,t,n,r)=>{let i=e.avail_in;return i>r&&(i=r),i===0?0:(e.avail_in-=i,t.set(e.input.subarray(e.next_in,e.next_in+i),n),e.state.wrap===1?e.adler=ba(e.adler,t,i,n):e.state.wrap===2&&(e.adler=Ae(e.adler,t,i,n)),e.next_in+=i,e.total_in+=i,i)},Sa=(e,t)=>{let n=e.max_chain_length,r=e.strstart,i,o,a=e.prev_length,s=e.nice_match;const l=e.strstart>e.w_size-ge?e.strstart-(e.w_size-ge):0,u=e.window,d=e.w_mask,p=e.prev,h=e.strstart+He;let g=u[r+a-1],y=u[r+a];e.prev_length>=e.good_match&&(n>>=2),s>e.lookahead&&(s=e.lookahead);do if(i=t,!(u[i+a]!==y||u[i+a-1]!==g||u[i]!==u[r]||u[++i]!==u[r+1])){r+=2,i++;do;while(u[++r]===u[++i]&&u[++r]===u[++i]&&u[++r]===u[++i]&&u[++r]===u[++i]&&u[++r]===u[++i]&&u[++r]===u[++i]&&u[++r]===u[++i]&&u[++r]===u[++i]&&r<h);if(o=He-(h-r),r=h-He,o>a){if(e.match_start=t,a=o,o>=s)break;g=u[r+a-1],y=u[r+a]}}while((t=p[t&d])>l&&--n!==0);return a<=e.lookahead?a:e.lookahead},ct=e=>{const t=e.w_size;let n,r,i;do{if(r=e.window_size-e.lookahead-e.strstart,e.strstart>=t+(t-ge)&&(e.window.set(e.window.subarray(t,t+t-r),0),e.match_start-=t,e.strstart-=t,e.block_start-=t,e.insert>e.strstart&&(e.insert=e.strstart),Ip(e),r+=t),e.strm.avail_in===0)break;if(n=cr(e.strm,e.window,e.strstart+e.lookahead,r),e.lookahead+=n,e.lookahead+e.insert>=A)for(i=e.strstart-e.insert,e.ins_h=e.window[i],e.ins_h=Ke(e,e.ins_h,e.window[i+1]);e.insert&&(e.ins_h=Ke(e,e.ins_h,e.window[i+A-1]),e.prev[i&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=i,i++,e.insert--,!(e.lookahead+e.insert<A)););}while(e.lookahead<ge&&e.strm.avail_in!==0)},va=(e,t)=>{let n=e.pending_buf_size-5>e.w_size?e.w_size:e.pending_buf_size-5,r,i,o,a=0,s=e.strm.avail_in;do{if(r=65535,o=e.bi_valid+42>>3,e.strm.avail_out<o||(o=e.strm.avail_out-o,i=e.strstart-e.block_start,r>i+e.strm.avail_in&&(r=i+e.strm.avail_in),r>o&&(r=o),r<n&&(r===0&&t!==ce||t===De||r!==i+e.strm.avail_in)))break;a=t===ce&&r===i+e.strm.avail_in?1:0,nr(e,0,0,a),e.pending_buf[e.pending-4]=r,e.pending_buf[e.pending-3]=r>>8,e.pending_buf[e.pending-2]=~r,e.pending_buf[e.pending-1]=~r>>8,ne(e.strm),i&&(i>r&&(i=r),e.strm.output.set(e.window.subarray(e.block_start,e.block_start+i),e.strm.next_out),e.strm.next_out+=i,e.strm.avail_out-=i,e.strm.total_out+=i,e.block_start+=i,r-=i),r&&(cr(e.strm,e.strm.output,e.strm.next_out,r),e.strm.next_out+=r,e.strm.avail_out-=r,e.strm.total_out+=r)}while(a===0);return s-=e.strm.avail_in,s&&(s>=e.w_size?(e.matches=2,e.window.set(e.strm.input.subarray(e.strm.next_in-e.w_size,e.strm.next_in),0),e.strstart=e.w_size,e.insert=e.strstart):(e.window_size-e.strstart<=s&&(e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,e.insert>e.strstart&&(e.insert=e.strstart)),e.window.set(e.strm.input.subarray(e.strm.next_in-s,e.strm.next_in),e.strstart),e.strstart+=s,e.insert+=s>e.w_size-e.insert?e.w_size-e.insert:s),e.block_start=e.strstart),e.high_water<e.strstart&&(e.high_water=e.strstart),a?_t:t!==De&&t!==ce&&e.strm.avail_in===0&&e.strstart===e.block_start?gt:(o=e.window_size-e.strstart,e.strm.avail_in>o&&e.block_start>=e.w_size&&(e.block_start-=e.w_size,e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,o+=e.w_size,e.insert>e.strstart&&(e.insert=e.strstart)),o>e.strm.avail_in&&(o=e.strm.avail_in),o&&(cr(e.strm,e.window,e.strstart,o),e.strstart+=o,e.insert+=o>e.w_size-e.insert?e.w_size-e.insert:o),e.high_water<e.strstart&&(e.high_water=e.strstart),o=e.bi_valid+42>>3,o=e.pending_buf_size-o>65535?65535:e.pending_buf_size-o,n=o>e.w_size?e.w_size:o,i=e.strstart-e.block_start,(i>=n||(i||t===ce)&&t!==De&&e.strm.avail_in===0&&i<=o)&&(r=i>o?o:i,a=t===ce&&e.strm.avail_in===0&&r===i?1:0,nr(e,e.block_start,r,a),e.block_start+=r,ne(e.strm)),a?je:G)},Kn=(e,t)=>{let n,r;for(;;){if(e.lookahead<ge){if(ct(e),e.lookahead<ge&&t===De)return G;if(e.lookahead===0)break}if(n=0,e.lookahead>=A&&(e.ins_h=Ke(e,e.ins_h,e.window[e.strstart+A-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),n!==0&&e.strstart-n<=e.w_size-ge&&(e.match_length=Sa(e,n)),e.match_length>=A)if(r=Ue(e,e.strstart-e.match_start,e.match_length-A),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=A){e.match_length--;do e.strstart++,e.ins_h=Ke(e,e.ins_h,e.window[e.strstart+A-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart;while(--e.match_length!==0);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=Ke(e,e.ins_h,e.window[e.strstart+1]);else r=Ue(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(r&&(ie(e,!1),e.strm.avail_out===0))return G}return e.insert=e.strstart<A-1?e.strstart:A-1,t===ce?(ie(e,!0),e.strm.avail_out===0?je:_t):e.sym_next&&(ie(e,!1),e.strm.avail_out===0)?G:gt},et=(e,t)=>{let n,r,i;for(;;){if(e.lookahead<ge){if(ct(e),e.lookahead<ge&&t===De)return G;if(e.lookahead===0)break}if(n=0,e.lookahead>=A&&(e.ins_h=Ke(e,e.ins_h,e.window[e.strstart+A-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=A-1,n!==0&&e.prev_length<e.max_lazy_match&&e.strstart-n<=e.w_size-ge&&(e.match_length=Sa(e,n),e.match_length<=5&&(e.strategy===mp||e.match_length===A&&e.strstart-e.match_start>4096)&&(e.match_length=A-1)),e.prev_length>=A&&e.match_length<=e.prev_length){i=e.strstart+e.lookahead-A,r=Ue(e,e.strstart-1-e.prev_match,e.prev_length-A),e.lookahead-=e.prev_length-1,e.prev_length-=2;do++e.strstart<=i&&(e.ins_h=Ke(e,e.ins_h,e.window[e.strstart+A-1]),n=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart);while(--e.prev_length!==0);if(e.match_available=0,e.match_length=A-1,e.strstart++,r&&(ie(e,!1),e.strm.avail_out===0))return G}else if(e.match_available){if(r=Ue(e,0,e.window[e.strstart-1]),r&&ie(e,!1),e.strstart++,e.lookahead--,e.strm.avail_out===0)return G}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(r=Ue(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<A-1?e.strstart:A-1,t===ce?(ie(e,!0),e.strm.avail_out===0?je:_t):e.sym_next&&(ie(e,!1),e.strm.avail_out===0)?G:gt},$p=(e,t)=>{let n,r,i,o;const a=e.window;for(;;){if(e.lookahead<=He){if(ct(e),e.lookahead<=He&&t===De)return G;if(e.lookahead===0)break}if(e.match_length=0,e.lookahead>=A&&e.strstart>0&&(i=e.strstart-1,r=a[i],r===a[++i]&&r===a[++i]&&r===a[++i])){o=e.strstart+He;do;while(r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&r===a[++i]&&i<o);e.match_length=He-(o-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=A?(n=Ue(e,1,e.match_length-A),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(n=Ue(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),n&&(ie(e,!1),e.strm.avail_out===0))return G}return e.insert=0,t===ce?(ie(e,!0),e.strm.avail_out===0?je:_t):e.sym_next&&(ie(e,!1),e.strm.avail_out===0)?G:gt},Ap=(e,t)=>{let n;for(;;){if(e.lookahead===0&&(ct(e),e.lookahead===0)){if(t===De)return G;break}if(e.match_length=0,n=Ue(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,n&&(ie(e,!1),e.strm.avail_out===0))return G}return e.insert=0,t===ce?(ie(e,!0),e.strm.avail_out===0?je:_t):e.sym_next&&(ie(e,!1),e.strm.avail_out===0)?G:gt};function le(e,t,n,r,i){this.good_length=e,this.max_lazy=t,this.nice_length=n,this.max_chain=r,this.func=i}const St=[new le(0,0,0,0,va),new le(4,4,8,4,Kn),new le(4,5,16,8,Kn),new le(4,6,32,32,Kn),new le(4,4,16,16,et),new le(8,16,32,32,et),new le(8,16,128,128,et),new le(8,32,128,256,et),new le(32,128,258,1024,et),new le(32,258,258,4096,et)],Np=e=>{e.window_size=2*e.w_size,Ne(e.head),e.max_lazy_match=St[e.level].max_lazy,e.good_match=St[e.level].good_length,e.nice_match=St[e.level].nice_length,e.max_chain_length=St[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=A-1,e.match_available=0,e.ins_h=0};function Hp(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=En,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(Tp*2),this.dyn_dtree=new Uint16Array((2*xp+1)*2),this.bl_tree=new Uint16Array((2*Pp+1)*2),Ne(this.dyn_ltree),Ne(this.dyn_dtree),Ne(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(Cp+1),this.heap=new Uint16Array(2*rr+1),Ne(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*rr+1),Ne(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const jt=e=>{if(!e)return 1;const t=e.state;return!t||t.strm!==e||t.status!==st&&t.status!==Hr&&t.status!==ir&&t.status!==or&&t.status!==ar&&t.status!==sr&&t.status!==Fe&&t.status!==kt?1:0},Oa=e=>{if(jt(e))return Ve(e,fe);e.total_in=e.total_out=0,e.data_type=yp;const t=e.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap===2?Hr:t.wrap?st:Fe,e.adler=t.wrap===2?0:1,t.last_flush=-2,sp(t),Y},xa=e=>{const t=Oa(e);return t===Y&&Np(e.state),t},Lp=(e,t)=>jt(e)||e.state.wrap!==2?fe:(e.state.gzhead=t,Y),Pa=(e,t,n,r,i,o)=>{if(!e)return fe;let a=1;if(t===hp&&(t=6),r<0?(a=0,r=-r):r>15&&(a=2,r-=16),i<1||i>bp||n!==En||r<8||r>15||t<0||t>9||o<0||o>gp||r===8&&a!==1)return Ve(e,fe);r===8&&(r=9);const s=new Hp;return e.state=s,s.strm=e,s.status=st,s.wrap=a,s.gzhead=null,s.w_bits=r,s.w_size=1<<s.w_bits,s.w_mask=s.w_size-1,s.hash_bits=i+7,s.hash_size=1<<s.hash_bits,s.hash_mask=s.hash_size-1,s.hash_shift=~~((s.hash_bits+A-1)/A),s.window=new Uint8Array(s.w_size*2),s.head=new Uint16Array(s.hash_size),s.prev=new Uint16Array(s.w_size),s.lit_bufsize=1<<i+6,s.pending_buf_size=s.lit_bufsize*4,s.pending_buf=new Uint8Array(s.pending_buf_size),s.sym_buf=s.lit_bufsize,s.sym_end=(s.lit_bufsize-1)*3,s.level=t,s.strategy=o,s.method=n,xa(e)},Up=(e,t)=>Pa(e,t,En,kp,Sp,_p),Dp=(e,t)=>{if(jt(e)||t>ui||t<0)return e?Ve(e,fe):fe;const n=e.state;if(!e.output||e.avail_in!==0&&!e.input||n.status===kt&&t!==ce)return Ve(e,e.avail_out===0?Dn:fe);const r=n.last_flush;if(n.last_flush=t,n.pending!==0){if(ne(e),e.avail_out===0)return n.last_flush=-1,Y}else if(e.avail_in===0&&di(t)<=di(r)&&t!==ce)return Ve(e,Dn);if(n.status===kt&&e.avail_in!==0)return Ve(e,Dn);if(n.status===st&&n.wrap===0&&(n.status=Fe),n.status===st){let i=En+(n.w_bits-8<<4)<<8,o=-1;if(n.strategy>=rn||n.level<2?o=0:n.level<6?o=1:n.level===6?o=2:o=3,i|=o<<6,n.strstart!==0&&(i|=Ep),i+=31-i%31,bt(n,i),n.strstart!==0&&(bt(n,e.adler>>>16),bt(n,e.adler&65535)),e.adler=1,n.status=Fe,ne(e),n.pending!==0)return n.last_flush=-1,Y}if(n.status===Hr){if(e.adler=0,N(n,31),N(n,139),N(n,8),n.gzhead)N(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),N(n,n.gzhead.time&255),N(n,n.gzhead.time>>8&255),N(n,n.gzhead.time>>16&255),N(n,n.gzhead.time>>24&255),N(n,n.level===9?2:n.strategy>=rn||n.level<2?4:0),N(n,n.gzhead.os&255),n.gzhead.extra&&n.gzhead.extra.length&&(N(n,n.gzhead.extra.length&255),N(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=Ae(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=ir;else if(N(n,0),N(n,0),N(n,0),N(n,0),N(n,0),N(n,n.level===9?2:n.strategy>=rn||n.level<2?4:0),N(n,Bp),n.status=Fe,ne(e),n.pending!==0)return n.last_flush=-1,Y}if(n.status===ir){if(n.gzhead.extra){let i=n.pending,o=(n.gzhead.extra.length&65535)-n.gzindex;for(;n.pending+o>n.pending_buf_size;){let s=n.pending_buf_size-n.pending;if(n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex,n.gzindex+s),n.pending),n.pending=n.pending_buf_size,n.gzhead.hcrc&&n.pending>i&&(e.adler=Ae(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex+=s,ne(e),n.pending!==0)return n.last_flush=-1,Y;i=0,o-=s}let a=new Uint8Array(n.gzhead.extra);n.pending_buf.set(a.subarray(n.gzindex,n.gzindex+o),n.pending),n.pending+=o,n.gzhead.hcrc&&n.pending>i&&(e.adler=Ae(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex=0}n.status=or}if(n.status===or){if(n.gzhead.name){let i=n.pending,o;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>i&&(e.adler=Ae(e.adler,n.pending_buf,n.pending-i,i)),ne(e),n.pending!==0)return n.last_flush=-1,Y;i=0}n.gzindex<n.gzhead.name.length?o=n.gzhead.name.charCodeAt(n.gzindex++)&255:o=0,N(n,o)}while(o!==0);n.gzhead.hcrc&&n.pending>i&&(e.adler=Ae(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex=0}n.status=ar}if(n.status===ar){if(n.gzhead.comment){let i=n.pending,o;do{if(n.pending===n.pending_buf_size){if(n.gzhead.hcrc&&n.pending>i&&(e.adler=Ae(e.adler,n.pending_buf,n.pending-i,i)),ne(e),n.pending!==0)return n.last_flush=-1,Y;i=0}n.gzindex<n.gzhead.comment.length?o=n.gzhead.comment.charCodeAt(n.gzindex++)&255:o=0,N(n,o)}while(o!==0);n.gzhead.hcrc&&n.pending>i&&(e.adler=Ae(e.adler,n.pending_buf,n.pending-i,i))}n.status=sr}if(n.status===sr){if(n.gzhead.hcrc){if(n.pending+2>n.pending_buf_size&&(ne(e),n.pending!==0))return n.last_flush=-1,Y;N(n,e.adler&255),N(n,e.adler>>8&255),e.adler=0}if(n.status=Fe,ne(e),n.pending!==0)return n.last_flush=-1,Y}if(e.avail_in!==0||n.lookahead!==0||t!==De&&n.status!==kt){let i=n.level===0?va(n,t):n.strategy===rn?Ap(n,t):n.strategy===fp?$p(n,t):St[n.level].func(n,t);if((i===je||i===_t)&&(n.status=kt),i===G||i===je)return e.avail_out===0&&(n.last_flush=-1),Y;if(i===gt&&(t===lp?up(n):t!==ui&&(nr(n,0,0,!1),t===dp&&(Ne(n.head),n.lookahead===0&&(n.strstart=0,n.block_start=0,n.insert=0))),ne(e),e.avail_out===0))return n.last_flush=-1,Y}return t!==ce?Y:n.wrap<=0?li:(n.wrap===2?(N(n,e.adler&255),N(n,e.adler>>8&255),N(n,e.adler>>16&255),N(n,e.adler>>24&255),N(n,e.total_in&255),N(n,e.total_in>>8&255),N(n,e.total_in>>16&255),N(n,e.total_in>>24&255)):(bt(n,e.adler>>>16),bt(n,e.adler&65535)),ne(e),n.wrap>0&&(n.wrap=-n.wrap),n.pending!==0?Y:li)},Kp=e=>{if(jt(e))return fe;const t=e.state.status;return e.state=null,t===Fe?Ve(e,pp):Y},Mp=(e,t)=>{let n=t.length;if(jt(e))return fe;const r=e.state,i=r.wrap;if(i===2||i===1&&r.status!==st||r.lookahead)return fe;if(i===1&&(e.adler=ba(e.adler,t,n,0)),r.wrap=0,n>=r.w_size){i===0&&(Ne(r.head),r.strstart=0,r.block_start=0,r.insert=0);let l=new Uint8Array(r.w_size);l.set(t.subarray(n-r.w_size,n),0),t=l,n=r.w_size}const o=e.avail_in,a=e.next_in,s=e.input;for(e.avail_in=n,e.next_in=0,e.input=t,ct(r);r.lookahead>=A;){let l=r.strstart,u=r.lookahead-(A-1);do r.ins_h=Ke(r,r.ins_h,r.window[l+A-1]),r.prev[l&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=l,l++;while(--u);r.strstart=l,r.lookahead=A-1,ct(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=A-1,r.match_available=0,e.next_in=a,e.input=s,e.avail_in=o,r.wrap=i,Y};var Rp=Up,zp=Pa,Fp=xa,Vp=Oa,qp=Lp,Yp=Dp,Zp=Kp,jp=Mp,Gp="pako deflate (from Nodeca project)",Ct={deflateInit:Rp,deflateInit2:zp,deflateReset:Fp,deflateResetKeep:Vp,deflateSetHeader:qp,deflate:Yp,deflateEnd:Zp,deflateSetDictionary:jp,deflateInfo:Gp};const Wp=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var Xp=function(e){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const n=t.shift();if(n){if(typeof n!="object")throw new TypeError(n+"must be non-object");for(const r in n)Wp(n,r)&&(e[r]=n[r])}}return e},Qp=e=>{let t=0;for(let r=0,i=e.length;r<i;r++)t+=e[r].length;const n=new Uint8Array(t);for(let r=0,i=0,o=e.length;r<o;r++){let a=e[r];n.set(a,i),i+=a.length}return n},Ta={assign:Xp,flattenChunks:Qp};let Ca=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{Ca=!1}const Lt=new Uint8Array(256);for(let e=0;e<256;e++)Lt[e]=e>=252?6:e>=248?5:e>=240?4:e>=224?3:e>=192?2:1;Lt[254]=Lt[254]=1;var Jp=e=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(e);let t,n,r,i,o,a=e.length,s=0;for(i=0;i<a;i++)n=e.charCodeAt(i),(n&64512)===55296&&i+1<a&&(r=e.charCodeAt(i+1),(r&64512)===56320&&(n=65536+(n-55296<<10)+(r-56320),i++)),s+=n<128?1:n<2048?2:n<65536?3:4;for(t=new Uint8Array(s),o=0,i=0;o<s;i++)n=e.charCodeAt(i),(n&64512)===55296&&i+1<a&&(r=e.charCodeAt(i+1),(r&64512)===56320&&(n=65536+(n-55296<<10)+(r-56320),i++)),n<128?t[o++]=n:n<2048?(t[o++]=192|n>>>6,t[o++]=128|n&63):n<65536?(t[o++]=224|n>>>12,t[o++]=128|n>>>6&63,t[o++]=128|n&63):(t[o++]=240|n>>>18,t[o++]=128|n>>>12&63,t[o++]=128|n>>>6&63,t[o++]=128|n&63);return t};const eh=(e,t)=>{if(t<65534&&e.subarray&&Ca)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));let n="";for(let r=0;r<t;r++)n+=String.fromCharCode(e[r]);return n};var th=(e,t)=>{const n=t||e.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(e.subarray(0,t));let r,i;const o=new Array(n*2);for(i=0,r=0;r<n;){let a=e[r++];if(a<128){o[i++]=a;continue}let s=Lt[a];if(s>4){o[i++]=65533,r+=s-1;continue}for(a&=s===2?31:s===3?15:7;s>1&&r<n;)a=a<<6|e[r++]&63,s--;if(s>1){o[i++]=65533;continue}a<65536?o[i++]=a:(a-=65536,o[i++]=55296|a>>10&1023,o[i++]=56320|a&1023)}return eh(o,i)},nh=(e,t)=>{t=t||e.length,t>e.length&&(t=e.length);let n=t-1;for(;n>=0&&(e[n]&192)===128;)n--;return n<0||n===0?t:n+Lt[e[n]]>t?n:t},Ea={string2buf:Jp,buf2string:th,utf8border:nh};function rh(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var ih=rh;const Ba=Object.prototype.toString,{Z_NO_FLUSH:oh,Z_SYNC_FLUSH:ah,Z_FULL_FLUSH:sh,Z_FINISH:ch,Z_OK:gn,Z_STREAM_END:uh,Z_DEFAULT_COMPRESSION:lh,Z_DEFAULT_STRATEGY:dh,Z_DEFLATED:ph}=ka;function Bn(e){this.options=Ta.assign({level:lh,method:ph,chunkSize:16384,windowBits:15,memLevel:8,strategy:dh},e||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new ih,this.strm.avail_out=0;let n=Ct.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(n!==gn)throw new Error(fn[n]);if(t.header&&Ct.deflateSetHeader(this.strm,t.header),t.dictionary){let r;if(typeof t.dictionary=="string"?r=Ea.string2buf(t.dictionary):Ba.call(t.dictionary)==="[object ArrayBuffer]"?r=new Uint8Array(t.dictionary):r=t.dictionary,n=Ct.deflateSetDictionary(this.strm,r),n!==gn)throw new Error(fn[n]);this._dict_set=!0}}Bn.prototype.push=function(e,t){const n=this.strm,r=this.options.chunkSize;let i,o;if(this.ended)return!1;for(t===~~t?o=t:o=t===!0?ch:oh,typeof e=="string"?n.input=Ea.string2buf(e):Ba.call(e)==="[object ArrayBuffer]"?n.input=new Uint8Array(e):n.input=e,n.next_in=0,n.avail_in=n.input.length;;){if(n.avail_out===0&&(n.output=new Uint8Array(r),n.next_out=0,n.avail_out=r),(o===ah||o===sh)&&n.avail_out<=6){this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;continue}if(i=Ct.deflate(n,o),i===uh)return n.next_out>0&&this.onData(n.output.subarray(0,n.next_out)),i=Ct.deflateEnd(this.strm),this.onEnd(i),this.ended=!0,i===gn;if(n.avail_out===0){this.onData(n.output);continue}if(o>0&&n.next_out>0){this.onData(n.output.subarray(0,n.next_out)),n.avail_out=0;continue}if(n.avail_in===0)break}return!0};Bn.prototype.onData=function(e){this.chunks.push(e)};Bn.prototype.onEnd=function(e){e===gn&&(this.result=Ta.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};function hh(e,t){const n=new Bn(t);if(n.push(e,!0),n.err)throw n.msg||fn[n.err];return n.result}var mh=hh,fh={deflate:mh};const{deflate:gh}=fh;var _h=gh;class yh{constructor(t){this.utxoSet=[],this.transactionMap={},this.network=Fs.MOCKNET,this.blockHeight=133700,this.options={updateUtxoSet:!0,...t},this.vmTarget=this.options.vmTarget??wi.BCH_2025_05}async getUtxos(t){const n=P(ln(t));return this.utxoSet.filter(([r])=>r===n).map(([,r])=>r)}setBlockHeight(t){this.blockHeight=t}async getBlockHeight(){return this.blockHeight}async getRawTransaction(t){return this.transactionMap[t]}async sendRawTransaction(t){const n=oe(t),r=P(Rn(Rn(n)).reverse());if(this.options.updateUtxoSet&&this.transactionMap[r])throw new Error(`Transaction with txid ${r} was already submitted`);if(this.transactionMap[r]=t,!this.options.updateUtxoSet)return r;const i=$i(n);return i.inputs.forEach(o=>{const a=this.utxoSet.findIndex(([,s])=>s.txid===P(o.outpointTransactionHash)&&s.vout===o.outpointIndex);if(a===-1)throw new Error(`UTXO not found for input ${o.outpointIndex} of transaction ${r}`);this.utxoSet.splice(a,1)}),i.outputs.forEach((o,a)=>{this.addUtxo(P(o.lockingBytecode),{txid:r,vout:a,satoshis:o.valueSatoshis,token:o.token&&Vs(o.token)})}),r}addUtxo(t,n){const r=Ai(t)?t:P(ln(t));this.utxoSet.push([r,n])}reset(){this.utxoSet=[],this.transactionMap={}}}const In=e=>{const t=qs(e.address);if(typeof t=="string")throw new Error(t);return`${e.artifact.contractName}_${P(t.payload)}_lock`},Lr=(e,t,n)=>`${e.artifact.contractName}_${t.name}_input${n}_unlock`,bh=e=>({[Mr.SCHNORR]:"schnorr_signature",[Mr.ECDSA]:"ecdsa_signature"})[e],kh=e=>({[U.SIGHASH_ALL]:"all_outputs",[U.SIGHASH_ALL|U.SIGHASH_ANYONECANPAY]:"all_outputs_single_input",[U.SIGHASH_ALL|U.SIGHASH_UTXOS]:"all_outputs_all_utxos",[U.SIGHASH_ALL|U.SIGHASH_ANYONECANPAY|U.SIGHASH_UTXOS]:"all_outputs_single_input_INVALID_all_utxos",[U.SIGHASH_SINGLE]:"corresponding_output",[U.SIGHASH_SINGLE|U.SIGHASH_ANYONECANPAY]:"corresponding_output_single_input",[U.SIGHASH_SINGLE|U.SIGHASH_UTXOS]:"corresponding_output_all_utxos",[U.SIGHASH_SINGLE|U.SIGHASH_ANYONECANPAY|U.SIGHASH_UTXOS]:"corresponding_output_single_input_INVALID_all_utxos",[U.SIGHASH_NONE]:"no_outputs",[U.SIGHASH_NONE|U.SIGHASH_ANYONECANPAY]:"no_outputs_single_input",[U.SIGHASH_NONE|U.SIGHASH_UTXOS]:"no_outputs_all_utxos",[U.SIGHASH_NONE|U.SIGHASH_ANYONECANPAY|U.SIGHASH_UTXOS]:"no_outputs_single_input_INVALID_all_utxos"})[e],Ia=e=>e.length>0?`0x${e}`:"",wa=(e,t)=>e.length===0?"// none":ot(e,t).reverse().map(([r,i])=>{if(i instanceof bn){const a=bh(i.getSignatureAlgorithm()),s=kh(i.getHashType(!1));return`<${r.name}.${a}.${s}> // ${r.type}`}const o=r.type==="bytes"?`bytes${i.length}`:r.type;return`<${r.name}> // ${o} = <${`0x${P(i)}`}>`}).join(`
`),Sh=e=>e.debug?na(Ti(oe(e.debug.bytecode)),e.debug.sourceMap,e.source):e.bytecode.split(" ").map(t=>Ai(t)?`<0x${t}>`:t).join(`
`),ur=e=>{if(e)return{amount:e.amount.toString(),category:e.category instanceof Uint8Array?P(e.category):e.category,nft:e.nft?{capability:e.nft.capability,commitment:e.nft.commitment instanceof Uint8Array?P(e.nft.commitment):e.nft.commitment}:void 0}},pi=e=>Array.isArray(e)&&e.length===1&&e[0]==="slot",$a=e=>{const t=gr(qe(e.unlockingBytecode)),n=t[0].data,r=t[1].data;return{signature:n,publicKey:r}},vh=e=>{if(e.inputs.some(a=>!dn(a)))throw new Error("Cannot use debugging functionality with a transaction that contains custom unlockers");const t=e.buildLibauthTransaction(),r={$schema:"https://ide.bitauth.com/authentication-template-v0.schema.json",description:"Imported from cashscript",name:"CashScript Generated Debugging Template",supported:[e.provider instanceof yh?e.provider.vmTarget:wi.BCH_2025_05],version:0,entities:xh(e),scripts:Ph(e),scenarios:Th(t,e)},i={},o={};for(const[a,s]of e.inputs.entries())if(We(s.unlocker)){const l=In(s.unlocker.contract);if(!l)continue;const u=Lh(s.unlocker.contract,s,l),d=P(t.inputs[a].unlockingBytecode);i[d]=u;const p=P(ln(s.unlocker.contract.address));o[p]=u}for(const a of Object.values(r.scenarios)){for(const[s,l]of t.inputs.entries()){const u=P(l.unlockingBytecode),d=i[u];d&&(pi(a?.sourceOutputs?.[s]?.lockingBytecode)||a.sourceOutputs?.[s]&&(a.sourceOutputs[s]={...a.sourceOutputs[s],lockingBytecode:d}))}for(const[s,l]of t.outputs.entries()){const u=P(l.lockingBytecode),d=o[u];d&&(pi(a?.transaction?.outputs?.[s]?.lockingBytecode)||a?.transaction?.outputs?.[s]&&(a.transaction.outputs[s]={...a.transaction.outputs[s],lockingBytecode:d}))}}return r},Oh=(e,t)=>{const n=t.inputs.map(r=>We(r.unlocker)?r.unlocker.contract:void 0).filter(r=>!!r).map(r=>r.artifact);return Sd(e,n)},pe=e=>`https://ide.bitauth.com/import-template/${(r=>r.replace(/\+/g,"-").replace(/\//g,"_"))(Ys(_h(fr(Zs(e)))))}`,xh=e=>e.inputs.map((n,r)=>{if(Ft(n.unlocker))return Ch(r);if(We(n.unlocker)){const i=kn(n.unlocker.abiFunction,n.unlocker.params??[]);return Eh(n.unlocker.contract,n.unlocker.abiFunction,i,r)}throw new Error("Unknown unlocker type")}).reduce((n,r)=>({...n,...r}),{}),Ph=e=>e.inputs.map((n,r)=>{if(Ft(n.unlocker))return Ih(r);if(We(n.unlocker)){const i=kn(n.unlocker.abiFunction,n.unlocker.params??[]);return wh(n.unlocker.contract,n.unlocker.abiFunction,i,n.unlocker.contract.encodedConstructorArgs,r)}throw new Error("Unknown unlocker type")}).reduce((n,r)=>({...n,...r}),{}),Th=(e,t)=>t.inputs.map((r,i)=>{if(Ft(r.unlocker))return Hh(e,t,i);if(We(r.unlocker)){const o=kn(r.unlocker.abiFunction,r.unlocker.params??[]);return Nh(r.unlocker.contract,e,t,r.unlocker.abiFunction,o,i)}throw new Error("Unknown unlocker type")}).reduce((r,i)=>({...r,...i}),{}),Ch=e=>{const t=`p2pkh_placeholder_lock_${e}`,n=`p2pkh_placeholder_unlock_${e}`;return{[`signer_${e}`]:{scripts:[t,n],description:`P2PKH data for input ${e}`,name:`P2PKH Signer (input #${e})`,variables:{[`signature_${e}`]:{description:"",name:`P2PKH Signature (input #${e})`,type:"WalletData"},[`public_key_${e}`]:{description:"",name:`P2PKH public key (input #${e})`,type:"WalletData"}}}}},Eh=(e,t,n,r)=>({[e.artifact.contractName+"_input"+r+"_parameters"]:{description:"Contract creation and function parameters",name:`${e.artifact.contractName} (input #${r})`,scripts:[In(e),Lr(e,t,r)],variables:{...Bh(e.artifact,t,n),...Kh(e.artifact.abi)}}}),Bh=(e,t,n)=>{const r=Object.fromEntries(t.inputs.map((o,a)=>[o.name,{description:`"${o.name}" parameter of function "${t.name}"`,name:o.name,type:n[a]instanceof bn?"Key":"WalletData"}])),i=Object.fromEntries(e.constructorInputs.map(o=>[o.name,{description:`"${o.name}" parameter of this contract`,name:o.name,type:"WalletData"}]));return{...r,...i}},Ih=e=>{const t=`p2pkh_placeholder_lock_${e}`;return{[`p2pkh_placeholder_unlock_${e}`]:{passes:[`P2PKH_spend_input${e}_evaluate`],name:`P2PKH Unlock (input #${e})`,script:`<signature_${e}>
<public_key_${e}>`,unlocks:t},[t]:{lockingType:"standard",name:`P2PKH Lock (input #${e})`,script:`OP_DUP
OP_HASH160 <$(<public_key_${e}> OP_HASH160
)> OP_EQUALVERIFY
OP_CHECKSIG`}}},wh=(e,t,n,r,i)=>{const o=Lr(e,t,i),a=In(e);return{[o]:Ah(e,t,n,i),[a]:$h(e,r)}},$h=(e,t)=>({lockingType:e.addressType,name:e.artifact.contractName,script:[`// "${e.artifact.contractName}" contract constructor parameters`,wa(e.artifact.constructorInputs,t),"","// bytecode",Sh(e.artifact)].join(`
`)}),Ah=(e,t,n,r)=>{const i=`${e.artifact.contractName}_${t.name}_input${r}_evaluate`,o=e.artifact.abi.findIndex(s=>s.name===t.name),a=e.artifact.abi.length>1?["// function index in contract",`<function_index> // int = <${o}>`,""]:[];return{passes:[i],name:`${t.name} (input #${r})`,script:[`// "${t.name}" function parameters`,wa(t.inputs,n),"",...a].join(`
`),unlocks:In(e)}},Nh=(e,t,n,r,i,o)=>{const a=e.artifact,s=e.encodedConstructorArgs;return{[`${a.contractName}_${r.name}_input${o}_evaluate`]:{name:`Evaluate ${a.contractName} ${r.name} (input #${o})`,description:"An example evaluation where this script execution passes.",data:{bytecode:{...Ua(r,e.artifact.abi),..._n(r.inputs,i),..._n(a.constructorInputs,s)},keys:{privateKeys:Ha(r.inputs,i)}},transaction:Aa(e,t,n,o),sourceOutputs:Na(n,t,o)}}},Hh=(e,t,n)=>{const r=`P2PKH_spend_input${n}_evaluate`,{signature:i,publicKey:o}=$a(e.inputs[n]);return{[r]:{name:`Evaluate P2PKH spend (input #${n})`,description:"An example evaluation where this script execution passes.",data:{bytecode:{[`signature_${n}`]:`0x${P(i)}`,[`public_key_${n}`]:`0x${P(o)}`}},transaction:Aa(void 0,e,t,n),sourceOutputs:Na(t,e,n)}}},Aa=(e,t,n,r)=>{const o=ot(n.inputs,t.inputs).map(([d,p],h)=>({outpointIndex:p.outpointIndex,outpointTransactionHash:P(p.outpointTransactionHash),sequenceNumber:p.sequenceNumber,unlockingBytecode:La(d,p,h,"p2pkh_placeholder_unlock",r===h)})),a=t.locktime,l=ot(n.outputs,t.outputs).map(([d,p])=>d&&e?{lockingBytecode:Dh(d,e),token:ur(p.token),valueSatoshis:Number(p.valueSatoshis)}:{lockingBytecode:`${P(p.lockingBytecode)}`,token:ur(p.token),valueSatoshis:Number(p.valueSatoshis)}),u=t.version;return{inputs:o,locktime:a,outputs:l,version:u}},Na=(e,t,n)=>ot(e.inputs,t.inputs).map(([i,o],a)=>({lockingBytecode:La(i,o,a,"p2pkh_placeholder_lock",a===n),valueSatoshis:Number(i.satoshis),token:ur(i.token)})),Lh=(e,{unlocker:t},n)=>{if(Ft(t))return{script:n};const r=e.artifact.constructorInputs.map(({name:o},a)=>[o,Ia(P(t.contract.encodedConstructorArgs[a]))]),i=Object.fromEntries(r);return{script:n,overrides:{bytecode:{...i}}}},Uh=(e,t,n,r)=>{if(Ft(e.unlocker)){const{signature:s,publicKey:l}=$a(t);return{script:`${n}_${r}`,overrides:{bytecode:{[`signature_${r}`]:`0x${P(s)}`,[`public_key_${r}`]:`0x${P(l)}`}}}}const i=e.unlocker.abiFunction,o=e.unlocker.contract,a=kn(i,e.unlocker.params);return{script:Lr(o,i,r),overrides:{bytecode:{...Ua(i,o.artifact.abi),..._n(i.inputs,a),..._n(o.artifact.constructorInputs,o.encodedConstructorArgs)},keys:{privateKeys:Ha(i.inputs,a)}}}},_n=(e,t)=>{const r=ot(e,t).filter(([,i])=>!(i instanceof bn)).map(([i,o])=>{const a=P(o),s=Ia(a);return[i.name,s]});return Object.fromEntries(r)},Ha=(e,t)=>{const r=ot(e,t).filter(([,i])=>i instanceof bn).map(([i,o])=>[i.name,P(o.privateKey)]);return Object.fromEntries(r)},La=(e,t,n,r,i)=>i?["slot"]:zn(e)&&dn(e)?Uh(e,t,r,n):{},Dh=(e,t)=>e.to instanceof Uint8Array?P(e.to):[t.address,t.tokenAddress].includes(e.to)?{}:P(ln(e.to)),Ua=(e,t)=>{const n=t.length>1?t.findIndex(r=>r.name===e.name):void 0;return n!==void 0?{function_index:n.toString()}:{}},Kh=e=>e.length>1?{function_index:{description:"Script function index to execute",name:"function_index",type:"WalletData"}}:{};function Mh(e){if(!We(e.unlocker))return{};const t=e.unlocker.contract,n=e.unlocker.abiFunction?.name,r=t.artifact.abi.find(o=>o.name===n);if(!r)throw new Error(`ABI function ${n} not found in contract artifact`);return{contract:{abiFunction:r,redeemScript:Ii(t.redeemScript),artifact:t.artifact}}}const Xh=()=>Uint8Array.from(Array(65)),Qh=()=>Uint8Array.from(Array(33)),Jh=e=>{const t=js(e);if(typeof t=="string")throw new Error(`Invalid address: ${t}`);const n=t.bytecode;return{generateLockingBytecode:()=>n,generateUnlockingBytecode:()=>Uint8Array.from(Array(0)),placeholder:!0}},Rh=4294967294;class em{constructor(t){this.inputs=[],this.outputs=[],this.locktime=0,this.provider=t.provider,this.options={allowImplicitFungibleTokenBurn:t.allowImplicitFungibleTokenBurn??!1,...t}}addInput(t,n,r){return this.addInputs([t],n,r)}addInputs(t,n,r){if(t.forEach(Gs),!n&&t.some(i=>!zn(i))||n&&t.some(i=>zn(i)))throw new Error("Either all UTXOs must have an individual unlocker specified, or no UTXOs must have an individual unlocker specified and a shared unlocker must be provided");return n?(this.inputs=this.inputs.concat(t.map(i=>({...i,unlocker:n,options:r}))),this):(this.inputs=this.inputs.concat(t),this)}addOutput(t){return this.addOutputs([t])}addOutputs(t){return t.forEach(Ws),this.outputs=this.outputs.concat(t),this}addOpReturnOutput(t){return this.outputs.push(Xs(t)),this}setLocktime(t){return this.locktime=t,this}checkMaxFee(t){const n=this.inputs.reduce((o,a)=>o+a.satoshis,0n),r=this.outputs.reduce((o,a)=>o+a.amount,0n),i=n-r;if(this.options.maximumFeeSatoshis&&i>this.options.maximumFeeSatoshis)throw new Error(`Transaction fee of ${i} is higher than max fee of ${this.options.maximumFeeSatoshis}`);if(this.options.maximumFeeSatsPerByte){const o=Rr(t).byteLength,a=Number((Number(i)/o).toFixed(2));if(a>this.options.maximumFeeSatsPerByte)throw new Error(`Transaction fee per byte of ${a} is higher than max fee per byte of ${this.options.maximumFeeSatsPerByte}`)}}checkFungibleTokenBurn(){if(this.options.allowImplicitFungibleTokenBurn)return;const t={},n={};for(const r of this.inputs)r.token?.amount&&(t[r.token.category]=(t[r.token.category]||0n)+r.token.amount);for(const r of this.outputs)r.token?.amount&&(n[r.token.category]=(n[r.token.category]||0n)+r.token.amount);for(const[r,i]of Object.entries(t)){const o=n[r]||0n;if(o<i)throw new Error(`Implicit burning of fungible tokens for category ${r} is not allowed (input amount: ${i}, output amount: ${o}). If this is intended, set allowImplicitFungibleTokenBurn to true.`)}}buildLibauthTransaction(){this.checkFungibleTokenBurn();const t=this.inputs.map(a=>({outpointIndex:a.vout,outpointTransactionHash:oe(a.txid),sequenceNumber:a.options?.sequence??Rh,unlockingBytecode:new Uint8Array})),n=this.outputs.map(Qs),r={inputs:t,locktime:this.locktime,outputs:n,version:2},i=zr(this.inputs);return this.inputs.map((a,s)=>a.unlocker.generateUnlockingBytecode({transaction:r,sourceOutputs:i,inputIndex:s})).forEach((a,s)=>{r.inputs[s].unlockingBytecode=a}),this.checkMaxFee(r),r}build(){const t=this.buildLibauthTransaction();return P(Rr(t))}debug(){if(this.inputs.some(n=>!dn(n)))throw new Error("Cannot debug a transaction with custom unlocker");return this.inputs.map(n=>"contract"in n.unlocker?n.unlocker.contract.artifact.compiler.version:null).filter(n=>n!==null).every(n=>Js.satisfies(n,">=0.11.0"))||console.warn("For the best debugging experience, please recompile your contract with cashc version 0.11.0 or newer."),Oh(this.getLibauthTemplate(),this)}getVmResourceUsage(t=!1){const n=this.debug(),r=[],i=[],o=(l,u,d=!1)=>`${a(l)} / ${a(u)}${d?` (${(l/u*100).toFixed(0)}%)`:""}`,a=l=>l.toLocaleString("en"),s=Object.entries(n);for(const[l,u]of this.inputs.entries()){const[,d]=s.find(([h])=>h.includes(`input${l}`))??[],p=d?.at(-1)?.metrics;if(!p)throw new Error("VM resource could not be calculated");r.push(p),i.push({"Contract - Function":We(u.unlocker)?`${u.unlocker.contract.name} - ${u.unlocker.abiFunction.name}`:"P2PKH Input",Ops:p.evaluatedInstructionCount,"Op Cost Budget Usage":o(p.operationCost,p.maximumOperationCost,!0),SigChecks:o(p.signatureCheckCount,p.maximumSignatureCheckCount),Hashes:o(p.hashDigestIterations,p.maximumHashDigestIterations)})}return t&&(console.log("VM Resource usage by inputs:"),console.table(i)),r}getBitauthUri(){return console.warn("WARNING: it is unsafe to use this Bitauth URI when using real private keys as they are included in the transaction template"),pe(this.getLibauthTemplate())}getLibauthTemplate(){return vh(this)}async send(t){const n=this.build();this.inputs.every(r=>dn(r))&&this.debug();try{const r=await this.provider.sendRawTransaction(n);return t?await this.getTxDetails(r,t):await this.getTxDetails(r)}catch(r){const i=r.error??r.message;throw new it(i,this.getBitauthUri())}}async getTxDetails(t,n){for(let r=0;r<1200;r+=1){await ec(500);try{const i=await this.provider.getRawTransaction(t);return n?i:{...tc(oe(i)),txid:t,hex:i}}catch{}}throw new Error("Could not retrieve transaction details for over 10 minutes")}generateWcTransactionObject(t){const n=this.build(),r=$i(oe(n)),o=zr(this.inputs).map((a,s)=>({...a,...r.inputs[s],...Mh(this.inputs[s])}));return{...t,transaction:r,sourceOutputs:o}}}function zh(){return Math.floor(Math.random()*1e5)}function Fh(e){let t;if(Vh(e))t=hi(e.url);else if(qh(e)){const{protocol:n,host:r,port:i}=e;if(n!=="http"&&n!=="https")throw new Error("Protocol should be 'http' or 'https'");t=hi(`${n}://${r}:${i}`)}else throw new Error("Invalid configuration: Either provide the url or protocol/host/port");return t}function hi(e){if(!e)throw new Error("URL is required");try{new URL(e)}catch{throw new Error("Invalid URL format")}return e}function Vh(e){return"url"in e}function qh(e){return"protocol"in e&&"hostname"in e&&"port"in e}var mi;(function(e){e[e.Mainnet=8332]="Mainnet",e[e.Testnet=18332]="Testnet",e[e.Testnet4=28332]="Testnet4",e[e.Scalenet=38332]="Scalenet",e[e.Regtest=18443]="Regtest"})(mi||(mi={}));class Yh extends Error{constructor(t){super(t),this.name="RetryLimitExceededError"}}var Zh=function(e,t,n,r){function i(o){return o instanceof n?o:new n(function(a){a(o)})}return new(n||(n=Promise))(function(o,a){function s(d){try{u(r.next(d))}catch(p){a(p)}}function l(d){try{u(r.throw(d))}catch(p){a(p)}}function u(d){d.done?o(d.value):i(d.value).then(s,l)}u((r=r.apply(e,t||[])).next())})};class jh{constructor(t){var n,r,i,o;if(this.url=Fh(t),!t.rpcUser)throw new Error("Need to provide rpcUser in config");if(!t.rpcPassword)throw new Error("Need to provide rpcPassword in config");this.rpcUser=t.rpcUser,this.rpcPassword=t.rpcPassword,this.maxRetries=(n=t.maxRetries)!==null&&n!==void 0?n:0,this.retryDelayMs=(r=t.retryDelayMs)!==null&&r!==void 0?r:100,this.logger=(i=t.logger)!==null&&i!==void 0?i:console,this.timeoutMs=(o=t.timeoutMs)!==null&&o!==void 0?o:5e3}request(t,...n){return Zh(this,void 0,void 0,function*(){var r;const i=nc.from(`${this.rpcUser}:${this.rpcPassword}`).toString("base64");for(let o=0;o<=this.maxRetries;o++)try{const a=yield fetch(this.url,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Basic ${i}`},body:JSON.stringify({jsonrpc:"2.0",method:t,params:n,id:zh()}),signal:AbortSignal.timeout(this.timeoutMs)}),s=yield a.json();if(!a.ok||s.error)throw new Error(`Error: ${((r=s.error)===null||r===void 0?void 0:r.message)||a.statusText}`);return s.result}catch(a){let s;if(typeof a=="string"?(s=a,this.logger.error(a)):a instanceof DOMException&&a.name==="TimeoutError"?(s=a.message,this.logger.error(`Request timed out after ${this.timeoutMs} ms`)):a instanceof Error&&(s=a.message,this.logger.error(`Request failed with error: ${a.message}`)),o<this.maxRetries)this.logger.warn(`Retrying request... (${o+1}/${this.maxRetries})`),yield new Promise(l=>setTimeout(l,this.retryDelayMs));else throw new Yh(`Request failed after ${this.maxRetries+1} attempts: ${s}`)}throw new Error("Request failed unexpectedly")})}}class tm{constructor(t,n,r){this.network=t,this.rpcClient=new jh({url:n,...r})}async getUtxos(t){return(await this.rpcClient.request("listunspent",0,9999999,[t])).map(i=>({txid:i.txid,vout:i.vout,satoshis:BigInt(i.amount*1e8)}))}async getBlockHeight(){return this.rpcClient.request("getblockcount")}async getRawTransaction(t){return this.rpcClient.request("getrawtransaction",t,0)}async sendRawTransaction(t){return this.rpcClient.request("sendrawtransaction",t)}getClient(){return this.rpcClient}}class nm{constructor(t,n){this.network=t,this.bchjs=n}async getUtxos(t){return((await this.bchjs.Electrumx.utxo(t)).utxos??[]).map(i=>({txid:i.tx_hash,vout:i.tx_pos,satoshis:BigInt(i.value)}))}async getBlockHeight(){return this.bchjs.Blockchain.getBlockCount()}async getRawTransaction(t){return this.bchjs.RawTransactions.getRawTransaction(t)}async sendRawTransaction(t){return this.bchjs.RawTransactions.sendRawTransaction(t)}}export{tm as BitcoinRpcNetworkProvider,om as Contract,am as ElectrumNetworkProvider,Dr as FailedRequireError,it as FailedTransactionError,Kr as FailedTransactionEvaluationError,nm as FullStackNetworkProvider,U as HashType,yh as MockNetworkProvider,Fs as Network,sm as NoDebugInformationInArtifactError,cm as OutputSatoshisTooSmallError,um as OutputTokenAmountTooSmallError,Mr as SignatureAlgorithm,bn as SignatureTemplate,lm as TokensToNonTokenAddressError,em as TransactionBuilder,dm as TypeError,pm as UndefinedInputError,wi as VmTarget,hm as encodeFunctionArgument,Mh as getWcContractInfo,We as isContractUnlocker,Ft as isP2PKHUnlocker,mm as isPlaceholderUnlocker,dn as isStandardUnlockableUtxo,fm as isStandardUnlocker,zn as isUnlockableUtxo,Jh as placeholderP2PKHUnlocker,Qh as placeholderPublicKey,Xh as placeholderSignature,gm as randomNFT,_m as randomToken,ym as randomUtxo,Wh as utils};
